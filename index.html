<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Directions demo</title>
  <style>
    /* Basic layout */
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #controls {
      padding: 12px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 1;
      background: white;
      position: relative;
    }
    #controls input {
      padding: 6px 8px;
      min-width: 220px;
    }
    #controls button {
      padding: 6px 12px;
      cursor: pointer;
    }
    #map {
      height: calc(100% - 52px); /* full height minus controls */
    }
    #error {
      color: #b00020;
      margin-left: 8px;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div id="controls" style="display:flex; flex-wrap:wrap; gap:12px; padding:8px;">
    <div style="display:flex; flex-direction:column; gap:4px; min-width:260px;">
      <label>
        Person 1:
        <!-- New Places widget -->
        <gmp-place-autocomplete
          id="addr1"
          placeholder="Person 1 address"
          requested-language="en"
        ></gmp-place-autocomplete>
      </label>
      <label>
        Mode 1:
        <select id="mode1">
          <option value="DRIVING" selected>Driving</option>
          <option value="WALKING">Walking</option>
          <option value="BICYCLING">Bicycling</option>
          <option value="TRANSIT">Transit</option>
        </select>
      </label>
    </div>

    <div style="display:flex; flex-direction:column; gap:4px; min-width:260px;">
      <label>
        Person 2:
        <!-- New Places widget -->
        <gmp-place-autocomplete
          id="addr2"
          placeholder="Person 2 address"
          requested-language="en"
        ></gmp-place-autocomplete>
      </label>
      <label>
        Mode 2:
        <select id="mode2">
          <option value="DRIVING" selected>Driving</option>
          <option value="WALKING">Walking</option>
          <option value="BICYCLING">Bicycling</option>
          <option value="TRANSIT">Transit</option>
        </select>
      </label>
    </div>

    <div style="display:flex; flex-direction:column; gap:4px; min-width:260px;">
      <label>
        Meeting point (where they meet):
        <!-- New Places widget -->
        <gmp-place-autocomplete
          id="meeting"
          placeholder="Meeting address (or click on map)"
          requested-language="en"
        ></gmp-place-autocomplete>
      </label>
      <small id="meetingHint">
        Click on the map to set the meeting point, or choose an address here.
      </small>
    </div>

    <div style="display:flex; flex-direction:column; gap:4px; min-width:260px;">
      <label>
        Destination (final place they go together):
        <!-- New Places widget -->
        <gmp-place-autocomplete
          id="destination"
          placeholder="Final destination address"
          requested-language="en"
        ></gmp-place-autocomplete>
      </label>
      <small>Used by “Optimize meeting point” and comparisons.</small>
    </div>

    <div style="display:flex; flex-direction:column; gap:4px;">
      <button id="optBtn">Optimize meeting point</button>
      <button id="routeBtn">Show routes</button>
      <button id="snapBtn">Snap meeting to safe place</button>
      <span id="error" style="color:#b00020; margin-top:4px;"></span>
    </div>
  </div>

  <div id="info" style="padding: 8px 12px; font-size: 0.9em; white-space: pre-line;"></div>

  <div id="map" style="height: calc(100vh - 120px);"></div>

  <!-- API key in config.js (window.GOOGLE_MAPS_API_KEY) -->
  <script src="config.js"></script>

  <!-- Load Google Maps (beta channel, Places+Marker libraries) -->
  <script>
    function loadGoogleMaps() {
      const key = window.GOOGLE_MAPS_API_KEY;
      if (!key) {
        console.error("Google Maps API key missing in config.js");
        return;
      }
      const script = document.createElement("script");
      script.src =
        "https://maps.googleapis.com/maps/api/js?key=" +
        key +
        "&callback=initMap&loading=async&v=beta&libraries=places,marker";
      script.async = true;
      script.defer = true;
      document.head.appendChild(script);
    }
    loadGoogleMaps();
  </script>

  <!-- Main logic -->
  <script>
    let map;
    let directionsService;
    let renderer1;
    let renderer2;
    let rendererDest; // Meeting -> Destination

    // Advanced marker for meeting point
    let meetingLatLng = null;
    let meetingMarker = null;

    let placesService = null;  

    // Stored addresses & locations from PlaceAutocompleteElement
    let addr1Address = "";
    let addr2Address = "";
    let meetingAddress = "";
    let destinationAddress = "";

    let addr1Location = null;
    let addr2Location = null;
    let destinationLocation = null;

    const SPEEDS_KMH = {
      DRIVING: 50,
      WALKING: 5,
      BICYCLING: 15,
      TRANSIT: 25,
    };

    function routePromise(request) {
      return new Promise((resolve, reject) => {
        directionsService.route(request, (result, status) => {
          if (status === google.maps.DirectionsStatus.OK) {
            resolve(result);
          } else {
            reject(status);
          }
        });
      });
    }

    function samplePath(path, num) {
      const candidates = [];
      if (!path || path.length < 2 || num <= 0) return candidates;

      if (path.length <= num + 2) {
        for (let i = 1; i < path.length - 1; i++) {
          candidates.push(path[i]);
        }
      } else {
        const step = Math.floor(path.length / (num + 1));
        for (let i = 1; i <= num; i++) {
          const idx = i * step;
          if (idx > 0 && idx < path.length - 1) {
            candidates.push(path[idx]);
          }
        }
      }
      return candidates;
    }

    function getSafeMeetingPoint(latLng) {
      return new Promise((resolve) => {
        if (!placesService || !latLng) {
          resolve(latLng);
          return;
        }

        // We request generic POIs, then filter to “safe-ish” ones ourselves
        const request = {
          location: latLng,
          rankBy: google.maps.places.RankBy.DISTANCE, // ✅ no radius here
          type: "point_of_interest",                  // ✅ single string
        };

        const preferredTypes = [
          "cafe",
          "restaurant",
          "parking",
          "park",
          "shopping_mall",
          "transit_station",
          "train_station",
          "bus_station",
          "subway_station",
        ];

        placesService.nearbySearch(request, (results, status) => {
          if (
            status !== google.maps.places.PlacesServiceStatus.OK ||
            !results ||
            results.length === 0
          ) {
            // No better place found → keep original point
            resolve(latLng);
            return;
          }

          // Pick the closest result that matches one of our “safe” types
          let chosen = results[0];
          for (const place of results) {
            if (
              place.types &&
              place.types.some((t) => preferredTypes.includes(t))
            ) {
              chosen = place;
              break;
            }
          }

          if (chosen.geometry && chosen.geometry.location) {
            resolve(chosen.geometry.location);
          } else {
            resolve(latLng);
          }
        });
      });
    }


    async function snapCurrentMeetingPoint() {
      const errorSpan = document.getElementById("error");
      errorSpan.textContent = "";

      if (!meetingLatLng) {
        errorSpan.textContent =
          "Please choose a meeting point (optimize, click on map, or select an address) before snapping.";
        return;
      }

      try {
        const safeLatLng = await getSafeMeetingPoint(meetingLatLng);

        if (!safeLatLng) {
          errorSpan.textContent = "Could not find a safer place nearby.";
          return;
        }

        // Move marker to the safe place
        clearMeetingPoint();
        setMeetingPoint(safeLatLng);
        map.panTo(safeLatLng);

        // Recompute all routes based on the new meeting point
        await calcRoutes();
      } catch (e) {
        console.error("Error snapping meeting point:", e);
        errorSpan.textContent = "Error while snapping meeting point.";
      }
    }


    function setupAutocompleteElement(elementId, onSelected) {
      const el = document.getElementById(elementId);
      if (!el) return null;

      // New Places widget event
      el.addEventListener("gmp-select", async ({ placePrediction }) => {
        try {
          const place = placePrediction.toPlace();
          await place.fetchFields({
            fields: ["formattedAddress", "location"],
          });
          onSelected(place);
        } catch (e) {
          console.error("Error in autocomplete for", elementId, e);
        }
      });

      return el;
    }

    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 6,
        center: { lat: 46.5, lng: 2.5 },
        mapId: window.GOOGLE_MAP_ID,
      });

      directionsService = new google.maps.DirectionsService();
      placesService = new google.maps.places.PlacesService(map);

      renderer1 = new google.maps.DirectionsRenderer({
        map: map,
        polylineOptions: { strokeColor: "#1a73e8" }, // Person 1
      });

      renderer2 = new google.maps.DirectionsRenderer({
        map: map,
        polylineOptions: { strokeColor: "#e91e63" }, // Person 2
      });

      rendererDest = new google.maps.DirectionsRenderer({
        map: map,
        polylineOptions: { strokeColor: "#00b894" }, // Meeting -> Destination
      });

      document.getElementById("routeBtn").addEventListener("click", () => {
        calcRoutes();
      });

      document.getElementById("optBtn").addEventListener("click", () => {
        optimizeMeetingPoint();
      });

      document.getElementById("snapBtn").addEventListener("click", () => {
        snapCurrentMeetingPoint();
      });

      // Setup new PlaceAutocompleteElement widgets
      setupAutocompleteElement("addr1", (place) => {
        addr1Address = place.formattedAddress || "";
        addr1Location = place.location || null;
      });

      setupAutocompleteElement("addr2", (place) => {
        addr2Address = place.formattedAddress || "";
        addr2Location = place.location || null;
      });

      setupAutocompleteElement("meeting", (place) => {
        meetingAddress = place.formattedAddress || "";
        if (place.location) {
          setMeetingPoint(place.location);
        }
      });

      setupAutocompleteElement("destination", (place) => {
        destinationAddress = place.formattedAddress || "";
        destinationLocation = place.location || null;
      });

      // Click on the map to choose the meeting point
      map.addListener("click", (e) => {
        setMeetingPoint(e.latLng);
        meetingAddress = ""; // "point on map" overrides any typed address
      });
    }

    // Expose initMap for the callback
    window.initMap = initMap;

    function setMeetingPoint(latLng) {
      meetingLatLng = latLng;

      if (!meetingMarker) {
        meetingMarker = new google.maps.marker.AdvancedMarkerElement({
          map,
          position: latLng,
          title: "Meeting point",
        });
      } else {
        meetingMarker.position = latLng;
      }

      const lat = latLng.lat().toFixed(5);
      const lng = latLng.lng().toFixed(5);
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent = `Meeting point set on map at (${lat}, ${lng}).`;
      }
    }

    function clearMeetingPoint() {
      meetingLatLng = null;
      meetingAddress = "";
      if (meetingMarker) {
        meetingMarker.map = null;
        meetingMarker = null;
      }
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent =
          "Click on the map to set the meeting point, or choose an address here.";
      }
    }

    async function calcRoutes() {
      const addr1 = addr1Address;
      const addr2 = addr2Address;
      const mode1 = document.getElementById("mode1").value;
      const mode2 = document.getElementById("mode2").value;
      const destText = destinationAddress;

      const errorSpan = document.getElementById("error");
      const infoDiv = document.getElementById("info");

      errorSpan.textContent = "";
      infoDiv.textContent = "";

      if (!addr1 || !addr2) {
        errorSpan.textContent =
          "Please select both person addresses from the suggestions.";
        return;
      }

      // Meeting point is where they go first
      let meetingDestination;
      if (meetingLatLng) {
        meetingDestination = meetingLatLng;
      } else if (meetingAddress) {
        meetingDestination = meetingAddress;
      } else {
        errorSpan.textContent =
          "Please choose a meeting point (click map or select an address).";
        return;
      }

      try {
        const origin1 = addr1Location || addr1;
        const origin2 = addr2Location || addr2;
        const finalDest = destinationLocation || destText;

        // --- Person 1 → Meeting ---
        const req1 = {
          origin: origin1,
          destination: meetingDestination,
          travelMode: google.maps.TravelMode[mode1],
        };
        const res1 = await routePromise(req1);
        renderer1.setDirections(res1);

        const leg1 = res1.routes[0]?.legs?.[0];
        let text1 = "";
        let t1 = null;

        if (leg1 && leg1.duration) {
          t1 = leg1.duration.value; // seconds
          text1 =
            "Person 1 → Meeting (" +
            mode1.toLowerCase() +
            "):\n" +
            "  Distance: " +
            (leg1.distance?.text || "?") +
            "\n" +
            "  Duration: " +
            (leg1.duration?.text || "?") +
            "\n";
        }

        // --- Person 2 → Meeting ---
        const req2 = {
          origin: origin2,
          destination: meetingDestination,
          travelMode: google.maps.TravelMode[mode2],
        };
        const res2 = await routePromise(req2);
        renderer2.setDirections(res2);

        const leg2 = res2.routes[0]?.legs?.[0];
        let text2 = "";
        let t2 = null;

        if (leg2 && leg2.duration) {
          t2 = leg2.duration.value; // seconds
          text2 =
            "\nPerson 2 → Meeting (" +
            mode2.toLowerCase() +
            "):\n" +
            "  Distance: " +
            (leg2.distance?.text || "?") +
            "\n" +
            "  Duration: " +
            (leg2.duration?.text || "?") +
            "\n";
        }

        infoDiv.textContent = text1 + text2;

        if (t1 != null && t2 != null) {
          const diff = Math.abs(t1 - t2);
          const total = t1 + t2;
          const diffMin = Math.round(diff / 60);
          const totalMin = Math.round(total / 60);
          infoDiv.textContent +=
            "\nTotal time to meeting (both): ~" +
            totalMin +
            " min" +
            "\nDifference in duration at meeting: ~" +
            diffMin +
            " min";
        }

        // --- Meeting → Destination (fastest mode from either person) ---
        if (!destText && !destinationLocation) {
          infoDiv.textContent +=
            "\n\nNo final destination set: skipping Meeting → Destination leg and comparisons.";
          rendererDest.setDirections({ routes: [] }); // clear
          return;
        }

        const v1 = SPEEDS_KMH[mode1] || 0;
        const v2 = SPEEDS_KMH[mode2] || 0;
        let finalMode = mode1;
        if (v2 > v1) {
          finalMode = mode2;
        }

        const originMD = meetingLatLng || meetingAddress;
        const reqDest = {
          origin: originMD,
          destination: finalDest,
          travelMode: google.maps.TravelMode[finalMode],
        };
        const resDest = await routePromise(reqDest);
        rendererDest.setDirections(resDest);

        const legDest = resDest.routes[0]?.legs?.[0];
        let tMD = null;

        if (legDest && legDest.duration) {
          tMD = legDest.duration.value; // seconds
          infoDiv.textContent +=
            "\n\nMeeting → Destination (" +
            finalMode.toLowerCase() +
            "):\n" +
            "  Distance: " +
            (legDest.distance?.text || "?") +
            "\n" +
            "  Duration: " +
            (legDest.duration?.text || "?") +
            "\n";
        }

        // --- Total times to Destination via Meeting ---
        let total1 = null;
        let total2 = null;
        if (t1 != null && t2 != null && tMD != null) {
          total1 = t1 + tMD;
          total2 = t2 + tMD;

          const total1Min = Math.round(total1 / 60);
          const total2Min = Math.round(total2 / 60);
          const diffEnd = Math.abs(total1 - total2);
          const diffEndMin = Math.round(diffEnd / 60);

          infoDiv.textContent +=
            "\nTotal time to destination via meeting:\n" +
            "  Person 1: ~" +
            total1Min +
            " min\n" +
            "  Person 2: ~" +
            total2Min +
            " min\n" +
            "  Difference at destination: ~" +
            diffEndMin +
            " min";

          const groupViaMin = Math.round((total1 + total2) / 60);
          infoDiv.textContent +=
            "\nGroup total via meeting: ~" + groupViaMin + " min";
        }

        // --- Direct comparison: each person going straight to Destination ---
        let direct1 = null;
        let direct2 = null;

        try {
          const resDirect1 = await routePromise({
            origin: origin1,
            destination: finalDest,
            travelMode: google.maps.TravelMode[mode1],
          });
          const legDirect1 = resDirect1.routes[0]?.legs?.[0];
          if (legDirect1 && legDirect1.duration) {
            direct1 = legDirect1.duration.value; // seconds
          }
        } catch (e1) {
          console.warn("Direct route Person 1 failed:", e1);
        }

        try {
          const resDirect2 = await routePromise({
            origin: origin2,
            destination: finalDest,
            travelMode: google.maps.TravelMode[mode2],
          });
          const legDirect2 = resDirect2.routes[0]?.legs?.[0];
          if (legDirect2 && legDirect2.duration) {
            direct2 = legDirect2.duration.value; // seconds
          }
        } catch (e2) {
          console.warn("Direct route Person 2 failed:", e2);
        }

        if (direct1 != null || direct2 != null) {
          infoDiv.textContent += "\n\nComparison with going directly to destination:";

          let total1, total2;
          // they may still be null if no meeting leg
          // but we've already guarded above for tMD/t1/t2

          if (t1 != null && tMD != null) total1 = t1 + tMD;
          if (t2 != null && tMD != null) total2 = t2 + tMD;

          let groupDirect = null;
          let groupVia = null;

          if (direct1 != null && total1 != null) {
            const direct1Min = Math.round(direct1 / 60);
            const total1Min = Math.round(total1 / 60);
            const delta1Min = total1Min - direct1Min;
            const sign1 = delta1Min > 0 ? "+" : "";
            infoDiv.textContent +=
              "\n  Person 1: direct ~" +
              direct1Min +
              " min, via meeting ~" +
              total1Min +
              " min (" +
              sign1 +
              delta1Min +
              " min)";
          }

          if (direct2 != null && total2 != null) {
            const direct2Min = Math.round(direct2 / 60);
            const total2Min = Math.round(total2 / 60);
            const delta2Min = total2Min - direct2Min;
            const sign2 = delta2Min > 0 ? "+" : "";
            infoDiv.textContent +=
              "\n  Person 2: direct ~" +
              direct2Min +
              " min, via meeting ~" +
              total2Min +
              " min (" +
              sign2 +
              delta2Min +
              " min)";
          }

          if (
            direct1 != null &&
            direct2 != null &&
            total1 != null &&
            total2 != null
          ) {
            groupDirect = direct1 + direct2;
            groupVia = total1 + total2;
            const groupDirectMin = Math.round(groupDirect / 60);
            const groupViaMin = Math.round(groupVia / 60);
            const deltaGroupMin = groupViaMin - groupDirectMin;
            const signG = deltaGroupMin > 0 ? "+" : "";
            infoDiv.textContent +=
              "\n\nGroup total direct: ~" +
              groupDirectMin +
              " min" +
              "\nGroup total via meeting: ~" +
              groupViaMin +
              " min" +
              "\nGroup difference: " +
              signG +
              deltaGroupMin +
              " min";
          }
        }
      } catch (err) {
        console.error("Error in calcRoutes:", err);
        errorSpan.textContent = "Error while computing routes.";
      }
    }

    async function optimizeMeetingPoint() {
      const addr1 = addr1Address;
      const addr2 = addr2Address;
      const mode1 = document.getElementById("mode1").value;
      const mode2 = document.getElementById("mode2").value;
      const destText = destinationAddress;

      const errorSpan = document.getElementById("error");
      const infoDiv = document.getElementById("info");

      errorSpan.textContent = "";
      infoDiv.textContent = "";

      if (!addr1 || !addr2) {
        errorSpan.textContent =
          "Please select both person addresses from the suggestions.";
        return;
      }
      if (!destText && !destinationLocation) {
        errorSpan.textContent = "Please select a final destination.";
        return;
      }

      const origin1 = addr1Location || addr1;
      const origin2 = addr2Location || addr2;
      const destination = destinationLocation || destText;
      const candidates = [];
      const numPerPath = 6; // tweak for precision vs API cost

      try {
        // 1) Person 1 -> Destination
        try {
          const r1Dest = await routePromise({
            origin: origin1,
            destination: destination,
            travelMode: google.maps.TravelMode[mode1],
          });
          const route = r1Dest.routes[0];
          if (route && route.overview_path) {
            candidates.push(...samplePath(route.overview_path, numPerPath));
          }
        } catch (e) {
          console.warn("Route P1 -> Dest failed (continuing):", e);
        }

        // 2) Person 1 -> Person 2
        try {
          const r1to2 = await routePromise({
            origin: origin1,
            destination: origin2,
            travelMode: google.maps.TravelMode[mode1],
          });
          const route = r1to2.routes[0];
          if (route && route.overview_path) {
            candidates.push(...samplePath(route.overview_path, numPerPath));
          }
        } catch (e) {
          console.warn("Route P1 -> P2 failed (continuing):", e);
        }

        // 3) Person 2 -> Destination
        try {
          const r2Dest = await routePromise({
            origin: origin2,
            destination: destination,
            travelMode: google.maps.TravelMode[mode2],
          });
          const route = r2Dest.routes[0];
          if (route && route.overview_path) {
            candidates.push(...samplePath(route.overview_path, numPerPath));
          }
        } catch (e) {
          console.warn("Route P2 -> Dest failed (continuing):", e);
        }

        if (candidates.length === 0) {
          errorSpan.textContent =
            "Could not generate candidate meeting points.";
          return;
        }

        // 4) Evaluate each candidate: P1 -> candidate, P2 -> candidate
        let bestCandidate = null;
        let bestTotal = Infinity;
        let bestDiff = Infinity;

        for (const point of candidates) {
          let res1;
          try {
            res1 = await routePromise({
              origin: origin1,
              destination: point,
              travelMode: google.maps.TravelMode[mode1],
            });
          } catch (status1) {
            console.warn("Skip candidate for Person 1, status:", status1);
            continue;
          }

          const leg1 = res1.routes[0]?.legs?.[0];
          if (!leg1 || !leg1.duration) continue;
          const t1 = leg1.duration.value;

          let res2;
          try {
            res2 = await routePromise({
              origin: origin2,
              destination: point,
              travelMode: google.maps.TravelMode[mode2],
            });
          } catch (status2) {
            console.warn("Skip candidate for Person 2, status:", status2);
            continue;
          }

          const leg2 = res2.routes[0]?.legs?.[0];
          if (!leg2 || !leg2.duration) continue;
          const t2 = leg2.duration.value;

          const total = t1 + t2;
          const diff = Math.abs(t1 - t2);

          // Primary: minimize total; secondary: fairness
          if (total < bestTotal || (total === bestTotal && diff < bestDiff)) {
            bestTotal = total;
            bestDiff = diff;
            bestCandidate = { point, t1, t2 };
          }
        }

        if (!bestCandidate) {
          errorSpan.textContent =
            "Could not find a good meeting point among candidates.";
          return;
        }

        // 5) Snap to a nearby safe place (cafe, parking, park, etc.)
        const rawLatLng = bestCandidate.point;
        const safeLatLng = await getSafeMeetingPoint(rawLatLng);

        // 6) Set the safe point as the meeting point
        clearMeetingPoint();
        setMeetingPoint(safeLatLng);
        map.panTo(safeLatLng);

        // 7) Show routes and comparisons
        await calcRoutes();
      } catch (err) {
        console.error("Error during optimization:", err);
        errorSpan.textContent = "Error while optimizing the meeting point.";
      }
    }
  </script>
</body>
</html>