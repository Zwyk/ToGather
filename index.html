<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ToGather ‚Äì Fair Meeting Point</title>
  <style>
    :root {
      --bg: #f3f4f6;
      --bg-elevated: #ffffff;
      --border-subtle: #d1d5db;
      --accent: #3b82f6;
      --accent-soft: rgba(59,130,246,0.12);
      --text-main: #111827;
      --text-muted: #6b7280;
      --danger: #ef4444;
      --chip-bg: #e5e7eb;
      --chip-bg-active: #dbeafe;
    }

    body.dark {
      --bg: #030712;
      --bg-elevated: #020617;
      --border-subtle: #1f2937;
      --accent: #60a5fa;
      --accent-soft: rgba(96,165,250,0.16);
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --danger: #f97373;
      --chip-bg: #111827;
      --chip-bg-active: #1f2937;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #controls {
      padding: 10px 12px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.15);
      z-index: 2;
      background: var(--bg-elevated);
      border-bottom: 1px solid var(--border-subtle);
    }

    #toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
    }

    #app-title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    #app-title h1 {
      font-size: 1.1rem;
      margin: 0;
      letter-spacing: 0.02em;
    }

    #app-title span {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    #toolbar-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #themeToggle {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 4px 10px;
      background: var(--chip-bg);
      color: var(--text-main);
      font-size: 0.85rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }

    #themeToggle span {
      font-size: 1rem;
    }

    #langSelect {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--chip-bg);
      color: var(--text-main);
      font-size: 0.8rem;
      padding: 4px 8px;
      cursor: pointer;
    }

    #langSelect:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #control-grid {
      display: grid;
      grid-template-columns: minmax(260px, 1.4fr) minmax(260px, 1fr) minmax(260px, 1fr);
      gap: 10px;
    }

    @media (max-width: 900px) {
      #control-grid {
        grid-template-columns: 1fr;
      }
    }

    .block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      background: var(--bg-elevated);
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      padding: 8px 10px;
    }

    .block label {
      font-size: 0.85rem;
      font-weight: 500;
    }

    .person-block {
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      padding: 6px 8px;
      background: var(--bg);
    }

    .person-result {
      margin-top: 6px;
      font-size: 0.8em;
      padding: 6px;
      border-radius: 6px;
      background: var(--bg-elevated);
      border: 1px dashed var(--border-subtle);
    }

    .person-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      margin-bottom: 4px;
    }
    .person-header button {
      font-size: 0.75em;
      padding: 2px 6px;
    }

    #controls button {
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--chip-bg);
      color: var(--text-main);
      font-size: 0.85rem;
    }

    #controls button:hover {
      background: var(--chip-bg-active);
    }

    input, select {
      font: inherit;
      padding: 5px 8px;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      box-sizing: border-box;
    }

    select {
      padding-right: 26px;
    }

    #map {
      flex: 1 1 auto;
      min-height: 40vh;
    }

    @media (min-width: 1024px) {
      #map {
        min-height: 70vh;
      }
    }

    #error {
      color: var(--danger);
      font-size: 0.85em;
    }

    .field-hint {
      font-size: 0.8em;
      color: var(--text-muted);
    }

    .validated-input {
      border: 1px solid #22c55e !important;
      background: rgba(34,197,94,0.08);
    }

    .pending-input {
      border: 1px solid #fbbf24 !important;
      background: rgba(251,191,36,0.08);
    }

    .inline-field {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .inline-field button {
      white-space: nowrap;
    }

    /* Details panel */
    #details-panel {
      margin-top: 6px;
      padding-top: 4px;
      border-top: 1px dashed var(--border-subtle);
    }

    #toggleDetailsBtn {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--chip-bg);
      font-size: 0.8rem;
      padding: 3px 10px;
      cursor: pointer;
    }

    #info {
      padding: 6px 2px;
      font-size: 0.85em;
      white-space: pre-line;
      display: none;
      color: var(--text-muted);
    }

    /* Loading overlay */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      font-weight: 500;
      color: #e5e7eb;
      z-index: 9999;
    }
  </style>
</head>

<body>
  <!-- Loading overlay for optimization -->
  <div id="loadingOverlay">
    <!-- Filled dynamically -->
  </div>

  <div id="controls">
    <div id="toolbar">
      <div id="app-title">
        <h1>ToGather</h1>
        <span id="subtitle">Find a fair meeting point for everyone</span>
      </div>
      <div id="toolbar-right">
        <select id="langSelect" aria-label="Language">
          <option value="en">EN</option>
          <option value="fr">FR</option>
        </select>
        <button id="themeToggle" type="button">
          <span id="themeToggleIcon">üåô</span>
          <span id="themeToggleLabel">Dark mode</span>
        </button>
      </div>
    </div>

    <div id="control-grid">
      <div class="block" style="min-width: 260px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong id="peopleTitle">People</strong>
          <button id="addPersonBtn" type="button">Add person</button>
        </div>
        <small id="peopleHint" class="field-hint">Each person has an address and a travel mode.</small>
        <div id="people-container" style="display:flex; flex-direction:column; gap:6px; margin-top:4px;"></div>
      </div>

      <div class="block">
        <label for="meeting-input" id="meetingLabel">Meeting point</label>
        <div class="inline-field">
          <input
            id="meeting-input"
            type="text"
            placeholder="Choose a meeting place or click on the map"
            style="flex: 1 1 180px;"
            title="You can choose a meeting place yourself, or leave it empty and use Optimize."
          />
          <button id="optBtn" type="button" title="Let the app compute a fair meeting point for everyone.">
            ‚öñÔ∏è Optimize
          </button>
          <button id="snapBtn" type="button" title="Snap the meeting point to a safe nearby place.">
            üìç Snap to safe
          </button>
        </div>
        <small id="meetingHint" class="field-hint">
          You can either:
          ‚Ä¢ click on the map or choose an address here, or
          ‚Ä¢ leave it empty and click <strong>Optimize</strong> to let the app find a fair meeting point.
        </small>
      </div>

      <div class="block">
        <label for="destination-input" id="destLabel">Destination</label>
        <input
          id="destination-input"
          type="text"
          placeholder="Final destination"
          style="width: 100%;"
          title="Start typing the final destination and pick a suggestion."
        />
        <small id="destHint" class="field-hint">
          Everyone will go here after meeting. Pick a suggestion to confirm the address.
        </small>

        <button id="routeBtn" type="button" style="margin-top:4px;">Show routes</button>
        <span id="error"></span>

        <div id="details-panel">
          <button id="toggleDetailsBtn" type="button" style="display:none;">Show details</button>
          <div id="info"></div>
        </div>

        <small id="tipText" class="field-hint">
          Tip: after typing an address, click a suggestion so the app can use it.
        </small>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <!-- API key + mapId in config.js -->
  <script src="config.js"></script>
  <script>
    // ---- i18n ----
    const I18N = {
      en: {
        subtitle: "Find a fair meeting point for everyone",
        peopleTitle: "People",
        peopleHint: "Each person has an address and a travel mode.",
        meetingLabel: "Meeting point",
        meetingPlaceholder: "Choose a meeting place or click on the map",
        meetingTitle: "You can choose a meeting place yourself, or leave it empty and use Optimize.",
        meetingHint: `You can either:
‚Ä¢ click on the map or choose an address here, or
‚Ä¢ leave it empty and click <strong>Optimize</strong> to let the app find a fair meeting point.`,
        destLabel: "Destination",
        destPlaceholder: "Final destination",
        destTitle: "Start typing the final destination and pick a suggestion.",
        destHint: "Everyone will go here after meeting. Pick a suggestion to confirm the address.",
        routeBtn: "Show routes",
        optBtn: "Optimize",
        snapBtn: "Snap to safe",
        tipText: "Tip: after typing an address, click a suggestion so the app can use it.",
        detailsShow: "Show details",
        detailsHide: "Hide details",
        themeDark: "Dark mode",
        themeLight: "Light mode",
        footerMain: "¬© 2025 ToGather ‚Äî Open-source tool to compute fair meeting points.",
        privacyLink: "Privacy Notice",
        termsLink: "Terms of Use",
        contactLink: "Contact",
        privacyTitle: "Privacy Notice",
        privacyBody: `
          <p>
            ToGather does not collect or store any personally identifiable data.
            Addresses you enter are processed only locally in your browser and sent
            directly to Google Maps services to compute routes and place
            suggestions. No information is transmitted to any server controlled by
            the creator of this tool.
          </p>
          <p>
            Since everything runs client-side, closing your browser window deletes
            all input data. Your browser may keep cached Google Maps results as part
            of normal web operation.
          </p>
          <p>
            By using this tool, you also accept the Google Maps Platform
            <a href="https://policies.google.com/privacy" target="_blank">Privacy Policy</a>.
          </p>
        `,
        termsTitle: "Terms of Use",
        termsBody: `
          <p>
            This tool is provided ‚Äúas-is‚Äù, without warranty of any kind. Results
            may be inaccurate due to real-world traffic variability, address
            coverage, or API limitations. You remain responsible for verifying all
            suggested routes and meeting locations.
          </p>
          <p>
            This project is non-commercial and open-source. You are free to fork,
            reuse, or modify the code under the MIT license (unless stated
            otherwise in the GitHub repository).
          </p>
          <p>
            The creator cannot be held liable for issues arising from inaccurate
            routing or misuse of the tool.
          </p>
        `,
        close: "Close",
      },
      fr: {
        subtitle: "Trouvez un point de rendez-vous √©quitable pour tout le monde",
        peopleTitle: "Personnes",
        peopleHint: "Chaque personne a une adresse et un mode de d√©placement.",
        meetingLabel: "Point de rendez-vous",
        meetingPlaceholder: "Choisissez un lieu ou cliquez sur la carte",
        meetingTitle: "Vous pouvez choisir vous-m√™me le lieu de rendez-vous ou laisser le bouton Optimiser le calculer.",
        meetingHint: `Vous pouvez :
‚Ä¢ cliquer sur la carte ou choisir une adresse ici, ou
‚Ä¢ laisser le champ vide et cliquer sur <strong>Optimiser</strong> pour que l‚Äôappli propose un point de rendez-vous √©quitable.`,
        destLabel: "Destination",
        destPlaceholder: "Destination finale",
        destTitle: "Commencez √† taper la destination finale puis choisissez une suggestion.",
        destHint: "Tout le monde ira ici apr√®s le rendez-vous. Choisissez une suggestion pour valider l‚Äôadresse.",
        routeBtn: "Afficher les trajets",
        optBtn: "Optimiser",
        snapBtn: "Ajuster vers un lieu pratique",
        tipText: "Astuce : apr√®s avoir saisi une adresse, cliquez sur une suggestion pour que l‚Äôappli puisse l‚Äôutiliser.",
        detailsShow: "Afficher les d√©tails",
        detailsHide: "Masquer les d√©tails",
        themeDark: "Mode sombre",
        themeLight: "Mode clair",
        footerMain: "¬© 2025 ToGather ‚Äî Outil open source pour trouver un point de rendez-vous √©quitable.",
        privacyLink: "Confidentialit√©",
        termsLink: "Conditions d‚Äôutilisation",
        contactLink: "Contact",
        privacyTitle: "Confidentialit√©",
        privacyBody: `
          <p>
            ToGather ne collecte ni ne stocke aucune donn√©e personnelle identifiable.
            Les adresses que vous saisissez sont trait√©es localement dans votre
            navigateur et envoy√©es directement aux services Google Maps pour calculer
            les itin√©raires et les lieux sugg√©r√©s. Aucune information n‚Äôest transmise
            √† un serveur contr√¥l√© par le cr√©ateur de l‚Äôoutil.
          </p>
          <p>
            Comme tout fonctionne c√¥t√© navigateur, fermer l‚Äôonglet suffit √† effacer
            les donn√©es saisies. Votre navigateur peut conserver un cache des
            r√©ponses Google Maps dans le cadre de son fonctionnement normal.
          </p>
          <p>
            En utilisant cet outil, vous acceptez √©galement la
            <a href="https://policies.google.com/privacy" target="_blank">Politique de confidentialit√©</a>
            de la plateforme Google Maps.
          </p>
        `,
        termsTitle: "Conditions d‚Äôutilisation",
        termsBody: `
          <p>
            Cet outil est fourni ¬´ tel quel ¬ª, sans aucune garantie. Les r√©sultats
            peuvent √™tre impr√©cis en raison du trafic r√©el, de la couverture des
            adresses ou des limites de l‚ÄôAPI. Vous restez responsable de la
            v√©rification des trajets et des lieux de rendez-vous propos√©s.
          </p>
          <p>
            Ce projet est non commercial et open source. Vous pouvez le forker,
            le r√©utiliser ou le modifier sous licence MIT (sauf mention contraire
            sur le d√©p√¥t GitHub).
          </p>
          <p>
            Le cr√©ateur ne peut √™tre tenu responsable d‚Äôun usage inappropri√© ou de
            cons√©quences li√©es √† des trajets inexacts.
          </p>
        `,
        close: "Fermer",
      },
    };

    let currentLang = "en";

    function applyLanguage(lang) {
      currentLang = I18N[lang] ? lang : "en";
      const dict = I18N[currentLang];

      document.documentElement.lang = currentLang;

      const subtitle = document.getElementById("subtitle");
      if (subtitle) subtitle.textContent = dict.subtitle;

      const peopleTitle = document.getElementById("peopleTitle");
      if (peopleTitle) peopleTitle.textContent = dict.peopleTitle;

      const peopleHint = document.getElementById("peopleHint");
      if (peopleHint) peopleHint.textContent = dict.peopleHint;

      const meetingLabel = document.getElementById("meetingLabel");
      if (meetingLabel) meetingLabel.textContent = dict.meetingLabel;

      const meetingInput = document.getElementById("meeting-input");
      if (meetingInput) {
        meetingInput.placeholder = dict.meetingPlaceholder;
        meetingInput.title = dict.meetingTitle;
      }

      const meetingHint = document.getElementById("meetingHint");
      if (meetingHint) meetingHint.innerHTML = dict.meetingHint;

      const destLabel = document.getElementById("destLabel");
      if (destLabel) destLabel.textContent = dict.destLabel;

      const destInput = document.getElementById("destination-input");
      if (destInput) {
        destInput.placeholder = dict.destPlaceholder;
        destInput.title = dict.destTitle;
      }

      const destHint = document.getElementById("destHint");
      if (destHint) destHint.textContent = dict.destHint;

      const routeBtn = document.getElementById("routeBtn");
      if (routeBtn) routeBtn.textContent = dict.routeBtn;

      const optBtn = document.getElementById("optBtn");
      if (optBtn) optBtn.textContent = "‚öñÔ∏è " + dict.optBtn;

      const snapBtn = document.getElementById("snapBtn");
      if (snapBtn) snapBtn.textContent = "üìç " + dict.snapBtn;

      const tipText = document.getElementById("tipText");
      if (tipText) tipText.textContent = dict.tipText;

      const detailsBtn = document.getElementById("toggleDetailsBtn");
      if (detailsBtn) {
        if (detailsBtn.style.display === "none" || !detailsBtn.style.display) {
          detailsBtn.textContent = dict.detailsShow;
        } else {
          detailsBtn.textContent = dict.detailsHide;
        }
      }

      const footerMain = document.getElementById("footerMain");
      if (footerMain) footerMain.textContent = dict.footerMain;

      const privacyLink = document.getElementById("openPrivacy");
      if (privacyLink) privacyLink.textContent = dict.privacyLink;

      const termsLink = document.getElementById("openTerms");
      if (termsLink) termsLink.textContent = dict.termsLink;

      const contactLink = document.getElementById("contactLink");
      if (contactLink) contactLink.textContent = dict.contactLink;

      const themeLabel = document.getElementById("themeToggleLabel");
      if (themeLabel) {
        const isDark = document.body.classList.contains("dark");
        themeLabel.textContent = isDark ? dict.themeLight : dict.themeDark;
      }

      const privacyTitle = document.getElementById("privacyTitle");
      if (privacyTitle) privacyTitle.textContent = dict.privacyTitle;
      const privacyBody = document.getElementById("privacyBody");
      if (privacyBody) privacyBody.innerHTML = dict.privacyBody;
      const privacyClose = document.getElementById("privacyCloseBtn");
      if (privacyClose) privacyClose.textContent = dict.close;

      const termsTitle = document.getElementById("termsTitle");
      if (termsTitle) termsTitle.textContent = dict.termsTitle;
      const termsBody = document.getElementById("termsBody");
      if (termsBody) termsBody.innerHTML = dict.termsBody;
      const termsClose = document.getElementById("termsCloseBtn");
      if (termsClose) termsClose.textContent = dict.close;
    }

    document.addEventListener("DOMContentLoaded", () => {
      const select = document.getElementById("langSelect");
      const saved = localStorage.getItem("tg_lang");
      let lang = saved || (navigator.language && navigator.language.toLowerCase().startsWith("fr") ? "fr" : "en");
      if (select) {
        select.value = lang;
        select.addEventListener("change", () => {
          const newLang = select.value;
          localStorage.setItem("tg_lang", newLang);
          applyLanguage(newLang);
        });
      }
      applyLanguage(lang);
    });

    // ---- Global state ----
    let map;
    let directionsService;
    let rendererDest; // Meeting -> Destination
    let personRenderers = [];

    let meetingLatLng = null;
    let meetingMarker = null;

    let meetingAddress = "";
    let destinationAddress = "";
    let destinationLocation = null;

    const SPEEDS_KMH = {
      DRIVING: 50,
      WALKING: 5,
      BICYCLING: 15,
      TRANSIT: 25,
    };

    const COLORS = ["#1a73e8", "#e91e63", "#f57c00", "#6a1b9a", "#388e3c", "#00897b"];

    // Initial test scenario
    const INITIAL_PERSONS = [
      {
        label: "Person 1",
        address: "10 Rue Daniel Hirtz, Strasbourg, France",
        mode: "DRIVING",
      },
      {
        label: "Person 2",
        address: "Parking Station, Rue de la Station, Strasbourg, France",
        mode: "WALKING",
      },
    ];
    const INITIAL_DEST = "Auchan Drive Hautepierre, Strasbourg, France";

    // Dynamic people list
    let people = [];
    let nextPersonId = 1;

    // Loading progress state
    let optimizationStartTime = null;
    const ROUTE_PHASE_WEIGHT = 0.4; // 40% for alt routes, 60% for evaluation

    // Map styles
    const MAP_STYLES_LIGHT = [];  // default Google look

    const MAP_STYLES_DARK = [
      { elementType: "geometry", stylers: [{ color: "#1f2933" }] },
      { elementType: "labels.text.fill", stylers: [{ color: "#e5e7eb" }] },
      { elementType: "labels.text.stroke", stylers: [{ color: "#111827" }] },
      {
        featureType: "road",
        elementType: "geometry",
        stylers: [{ color: "#374151" }]
      },
      {
        featureType: "water",
        elementType: "geometry",
        stylers: [{ color: "#0f172a" }]
      },
      {
        featureType: "poi",
        elementType: "labels.icon",
        stylers: [{ visibility: "off" }]
      },
    ];

    // ---- Theme handling ----
    function applyTheme(theme) {
      const body = document.body;
      const iconSpan = document.getElementById("themeToggleIcon");
      const labelSpan = document.getElementById("themeToggleLabel");

      const dark = theme === "dark";
      body.classList.toggle("dark", dark);

      if (window.google && map) {
        map.setOptions({
          styles: dark ? MAP_STYLES_DARK : MAP_STYLES_LIGHT,
        });
      }

      const dict = I18N[currentLang] || I18N.en;

      if (dark) {
        if (iconSpan) iconSpan.textContent = "‚òÄÔ∏è";
        if (labelSpan) labelSpan.textContent = dict.themeLight;
      } else {
        if (iconSpan) iconSpan.textContent = "üåô";
        if (labelSpan) labelSpan.textContent = dict.themeDark;
      }
    }

    function initTheme() {
      const stored = localStorage.getItem("tg_theme");
      let theme = stored;
      if (!theme) {
        theme = window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light";
      }
      applyTheme(theme);
    }

    function toggleTheme() {
      const isDark = document.body.classList.contains("dark");
      const next = isDark ? "light" : "dark";
      localStorage.setItem("tg_theme", next);
      applyTheme(next);
    }

    // ---- Loading overlay helpers ----
    function showLoading(initialMessage = "Preparing optimization‚Ä¶") {
      optimizationStartTime = Date.now();
      const overlay = document.getElementById("loadingOverlay");
      overlay.style.display = "flex";
      updateLoading(initialMessage, 0);
    }

    function updateLoading(message, progress) {
      const overlay = document.getElementById("loadingOverlay");
      if (!overlay || overlay.style.display === "none") return;

      const p = Math.max(0, Math.min(1, progress || 0));
      const pct = Math.round(p * 100);

      const now = Date.now();
      const elapsedSec = optimizationStartTime ? (now - optimizationStartTime) / 1000 : 0;

      let etaText = "";
      if (p > 0.05 && elapsedSec > 1) {
        const totalEstSec = elapsedSec / p;
        const remainingSec = Math.max(0, totalEstSec - elapsedSec);
        const rem = Math.round(remainingSec);
        if (rem < 60) {
          etaText = `Estimated time remaining: ~${rem}s`;
        } else {
          const remMin = Math.round(rem / 60);
          etaText = `Estimated time remaining: ~${remMin} min`;
        }
      }

      overlay.innerHTML = `
        <div style="text-align:center; padding:16px 24px; border-radius:12px; background:#020617ee; box-shadow:0 2px 8px rgba(0,0,0,0.35); color:#e5e7eb; min-width:240px;">
          <div style="font-weight:600; margin-bottom:4px;">${message}</div>
          <div style="margin-top:4px;">Progress: ${pct}%</div>
          ${etaText ? `<div style="margin-top:4px; font-size:0.9em; opacity:.85;">${etaText}</div>` : ""}
        </div>
      `;
    }

    function hideLoading() {
      const overlay = document.getElementById("loadingOverlay");
      overlay.style.display = "none";
    }

    // ---- Helpers ----

    function routePromise(request) {
      return new Promise((resolve, reject) => {
        directionsService.route(request, (result, status) => {
          if (status === google.maps.DirectionsStatus.OK) {
            resolve(result);
          } else {
            reject(status);
          }
        });
      });
    }

    function findIntermediatePoints(path, num) {
      const candidates = [];
      if (!path || path.length < 2 || num <= 0) return candidates;
      const step = Math.floor(path.length / (num + 1));
      if (step <= 0) return candidates;
      for (let i = 1; i <= num; i++) {
        const idx = i * step;
        if (idx > 0 && idx < path.length - 1) {
          candidates.push(path[idx]);
        }
      }
      return candidates;
    }

    // Attach a Places Autocomplete to a text input
    function setupAutocompleteInput(inputEl, onPlaceSelected) {
      if (!inputEl) return null;

      setValidationState(inputEl, false);

      const autocomplete = new google.maps.places.Autocomplete(inputEl, {
        fields: ["geometry", "formatted_address", "name"],
      });

      autocomplete.addListener("place_changed", () => {
        const place = autocomplete.getPlace();
        if (!place || !place.geometry || !place.geometry.location) {
          setValidationState(inputEl, false);
          return;
        }

        const location = place.geometry.location;
        const formattedAddress =
          place.formatted_address || place.name || inputEl.value;

        onPlaceSelected({
          location,
          formattedAddress,
        });

        setValidationState(inputEl, true);
      });

      inputEl.addEventListener("input", () => {
        setValidationState(inputEl, false);
      });

      return autocomplete;
    }

    // Places API (new) nearby search to find a "safe" meeting place
    async function getSafeMeetingPoint(latLng) {
      if (!latLng) return latLng;

      const apiKey = window.GOOGLE_MAPS_API_KEY;
      if (!apiKey) return latLng;

      const center = {
        latitude: typeof latLng.lat === "function" ? latLng.lat() : latLng.lat,
        longitude: typeof latLng.lng === "function" ? latLng.lng() : latLng.lng,
      };

      const requestBody = {
        includedTypes: [
          "cafe",
          "restaurant",
          "parking",
          "park",
          "shopping_mall",
          "transit_station",
          "train_station",
          "bus_station",
          "subway_station",
        ],
        maxResultCount: 10,
        rankPreference: "DISTANCE",
        locationRestriction: {
          circle: {
            center,
            radius: 500.0,
          },
        },
      };

      try {
        const response = await fetch("https://places.googleapis.com/v1/places:searchNearby", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Goog-Api-Key": apiKey,
            "X-Goog-FieldMask": "places.location,places.types",
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          console.warn("Nearby search failed:", response.status, response.statusText);
          return latLng;
        }

        const data = await response.json();
        if (!data.places || data.places.length === 0) return latLng;

        const preferredTypes = [
          "cafe",
          "restaurant",
          "parking",
          "park",
          "shopping_mall",
          "transit_station",
          "train_station",
          "bus_station",
          "subway_station",
        ];

        let chosen = data.places[0];
        for (const place of data.places) {
          if (place.types && place.types.some((t) => preferredTypes.includes(t))) {
            chosen = place;
            break;
          }
        }

        if (
          chosen.location &&
          typeof chosen.location.latitude === "number" &&
          typeof chosen.location.longitude === "number"
        ) {
          return new google.maps.LatLng(
            chosen.location.latitude,
            chosen.location.longitude
          );
        }

        return latLng;
      } catch (err) {
        console.error("Places Nearby (new) error:", err);
        return latLng;
      }
    }

    function reverseGeocodeLatLng(latLng) {
      return new Promise((resolve, reject) => {
        const geocoder = new google.maps.Geocoder();
        geocoder.geocode({ location: latLng }, (results, status) => {
          if (status === google.maps.GeocoderStatus.OK && results[0]) {
            resolve(results[0].formatted_address);
          } else {
            console.warn("Reverse geocoding failed:", status);
            resolve(null);
          }
        });
      });
    }

    async function snapCurrentMeetingPoint() {
      const errorSpan = document.getElementById("error");
      errorSpan.textContent = "";

      if (!meetingLatLng) {
        errorSpan.textContent =
          "Please choose a meeting point (optimize, click on map, or select an address) before snapping.";
        return;
      }

      const safeLatLng = await getSafeMeetingPoint(meetingLatLng);
      clearMeetingPoint();
      setMeetingPoint(safeLatLng);
      map.panTo(safeLatLng);

      try {
        const meetingInput = document.getElementById("meeting-input");
        const addr = await reverseGeocodeLatLng(safeLatLng);
        if (addr) {
          meetingAddress = addr;
          if (meetingInput) {
            meetingInput.value = addr;
            if (typeof setValidationState === "function") {
              setValidationState(meetingInput, true);
            }
          }
        }
      } catch (e) {
        console.error("Failed to reverse geocode meeting point:", e);
      }

      updateLoading("Finalizing routes‚Ä¶", 1);
      hideLoading();
      await calcRoutes();
    }

    function setMeetingPoint(latLng) {
      if (!latLng) {
        console.warn("setMeetingPoint called with null/undefined");
        return;
      }

      meetingLatLng = latLng;

      if (!meetingMarker) {
        meetingMarker = new google.maps.Marker({
          map,
          position: latLng,
          title: "Meeting point",
        });
      } else {
        meetingMarker.position = latLng;
      }

      const lat = latLng.lat().toFixed(5);
      const lng = latLng.lng().toFixed(5);
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent = `Meeting point: (${lat}, ${lng}).`;
      }
    }

    function clearMeetingPoint() {
      meetingLatLng = null;
      if (meetingMarker) {
        meetingMarker.setMap(null);
        meetingMarker = null;
      }
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent =
          "Click on the map to set the meeting point, or choose an address here.";
      }
    }

    function addPerson(initial) {
      const id = nextPersonId++;
      const labelText = initial?.label || `Person ${id}`;

      const container = document.getElementById("people-container");
      const wrapper = document.createElement("div");
      wrapper.className = "person-block";
      wrapper.dataset.personId = String(id);

      wrapper.innerHTML = `
        <div class="person-header">
          <span>${labelText}</span>
          <button type="button" class="delete-person">Delete</button>
        </div>
        <label>Address</label>
        <input
          type="text"
          class="person-address"
          placeholder="${labelText} address"
          style="width: 100%;"
          title="Start typing an address and pick a suggestion."
        />
        <small class="field-hint">
          Make sure you choose a suggestion so the address is applied.
        </small>
        <label style="margin-top:4px;">
          Mode:
          <select title="Choose how this person travels to the meeting point and destination.">
            <option value="DRIVING">üöó Driving</option>
            <option value="WALKING" selected>üö∂ Walking</option>
            <option value="BICYCLING">üö≤ Cycling</option>
            <option value="TRANSIT">üöÜ Transit</option>
          </select>
        </label>
      `;

      container.appendChild(wrapper);

      const addressInput = wrapper.querySelector("input.person-address");
      const modeSelect = wrapper.querySelector("select");
      const deleteBtn = wrapper.querySelector(".delete-person");

      if (initial?.address) {
        addressInput.value = initial.address;
      }

      const person = {
        id,
        label: labelText,
        element: wrapper,
        addressInput,
        modeSelect,
        address: initial?.address || "",
        location: null,
        defaultAddress: initial?.address || "",
      };

      if (initial?.mode) {
        modeSelect.value = initial.mode;
      }

      setupAutocompleteInput(addressInput, (place) => {
        person.address = place.formattedAddress || place.formatted_address || "";
        person.location = place.location || null;
      });

      deleteBtn.addEventListener("click", () => {
        people = people.filter((p) => p !== person);
        wrapper.remove();
      });

      people.push(person);
    }

    // ---- Details helper ----
    function setDetailsText(text) {
      const infoDiv = document.getElementById("info");
      const btn = document.getElementById("toggleDetailsBtn");

      infoDiv.textContent = text || "";

      const dict = I18N[currentLang] || I18N.en;

      if (text && text.trim()) {
        btn.style.display = "inline-block";
        btn.textContent = dict.detailsShow;
        infoDiv.style.display = "none";
      } else {
        btn.style.display = "none";
        infoDiv.style.display = "none";
      }
    }

    // ---- Map init ----
    function initMap() {
      initTheme();

      const isDark = document.body.classList.contains("dark");

      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 11,
        center: { lat: 48.5734, lng: 7.7521 },
        styles: isDark ? MAP_STYLES_DARK : MAP_STYLES_LIGHT,
      });

      directionsService = new google.maps.DirectionsService();
      rendererDest = new google.maps.DirectionsRenderer({
        map,
        polylineOptions: { strokeColor: "#00b894" },
      });

      document.getElementById("themeToggle").addEventListener("click", toggleTheme);

      document.getElementById("routeBtn").addEventListener("click", () => {
        calcRoutes();
      });

      document.getElementById("optBtn").addEventListener("click", () => {
        optimizeMeetingPoint();
      });

      document.getElementById("snapBtn").addEventListener("click", () => {
        snapCurrentMeetingPoint();
      });

      document.getElementById("addPersonBtn").addEventListener("click", () => {
        addPerson();
      });

      document.getElementById("toggleDetailsBtn").addEventListener("click", () => {
        const infoDiv = document.getElementById("info");
        const btn = document.getElementById("toggleDetailsBtn");
        const isVisible = infoDiv.style.display !== "none";

        const dict = I18N[currentLang] || I18N.en;

        if (isVisible) {
          infoDiv.style.display = "none";
          btn.textContent = dict.detailsShow;
        } else {
          infoDiv.style.display = "block";
          btn.textContent = dict.detailsHide;
        }
      });

      // Meeting autocomplete
      const meetingInput = document.getElementById("meeting-input");
      setupAutocompleteInput(meetingInput, (place) => {
        meetingAddress = place.formattedAddress || "";
        if (place.location) {
          setMeetingPoint(place.location);
        } else {
          clearMeetingPoint();
        }
      });

      // Destination autocomplete
      const destinationInput = document.getElementById("destination-input");
      setupAutocompleteInput(destinationInput, (place) => {
        destinationAddress = place.formattedAddress || "";
        destinationLocation = place.location || null;
      });

      // Initial scenario: 2 people
      INITIAL_PERSONS.forEach((p) => addPerson(p));

      if (INITIAL_DEST) {
        destinationInput.value = INITIAL_DEST;
      }

      // Meeting from map click
      map.addListener("click", (e) => {
        setMeetingPoint(e.latLng);
        meetingAddress = "";
      });
    }
    window.initMap = initMap;

    // ---- Core logic: routes & optimization ----

    async function calcRoutes() {
      const errorSpan = document.getElementById("error");
      errorSpan.textContent = "";
      setDetailsText("");

      people.forEach(p => {
        const old = p.element.querySelector(".person-result");
        if (old) old.remove();
      });

      if (people.length === 0) {
        errorSpan.textContent = "Add at least one person.";
        return;
      }

      const destText = destinationAddress || INITIAL_DEST;
      if (!destText && !destinationLocation) {
        errorSpan.textContent = "Please choose a destination.";
        return;
      }
      const finalDest = destinationLocation || destText;

      let meetingDestination;
      if (meetingLatLng) {
        meetingDestination = meetingLatLng;
      } else if (meetingAddress) {
        meetingDestination = meetingAddress;
      } else {
        errorSpan.textContent =
          "Please choose a meeting point (optimize, click on map, or select an address) before snapping.";
        return;
      }

      personRenderers.forEach((r) => r.setMap(null));
      personRenderers = [];

      let text = "";
      const personResults = [];
      let bounds = new google.maps.LatLngBounds();

      try {
        // For each person: origin -> meeting
        let idx = 0;
        for (const person of people) {
          const displayName = person.label || `Person ${idx + 1}`;
          const originAddress =
            person.address || person.defaultAddress || "";
          const mode = person.modeSelect.value;

          if (!originAddress && !person.location) {
            errorSpan.textContent =
              `Please select an address for ${displayName}.`;
            return;
          }

          const origin = person.location || originAddress;
          const req = {
            origin,
            destination: meetingDestination,
            travelMode: google.maps.TravelMode[mode],
          };
          const res = await routePromise(req);

          const renderer = new google.maps.DirectionsRenderer({
            map,
            polylineOptions: { strokeColor: COLORS[idx % COLORS.length] },
          });
          renderer.setDirections(res);
          personRenderers.push(renderer);

          const leg = res.routes[0]?.legs?.[0];
          if (!leg || !leg.duration) continue;

          if (leg.start_location) bounds.extend(leg.start_location);
          if (leg.end_location) bounds.extend(leg.end_location);

          const t = leg.duration.value;
          const dText = leg.distance?.text || "?";
          const tText = leg.duration?.text || "?";

          personResults.push({
            person,
            displayName,
            mode,
            tMeeting: t,
          });

          const resultDiv = document.createElement("div");
          resultDiv.className = "person-result";
          resultDiv.innerHTML = `
            üß≠ Route:<br>
            ‚Ä¢ Distance: ${dText}<br>
            ‚Ä¢ Duration: ${tText}<br>
            ‚Ä¢ Mode: ${mode.toLowerCase()}
          `;
          person.element.appendChild(resultDiv);

          text += `${displayName} ‚Üí Meeting (${mode.toLowerCase()}): ${dText}, ${tText}\n`;
          idx++;
        }

        if (personResults.length === 0) {
          errorSpan.textContent = "Could not compute routes to meeting.";
          return;
        }

        // Meeting ‚Üí Destination : choose intrinsically fastest mode
        let fastestMode = "WALKING";
        let bestSpeed = 0;
        for (const pRes of personResults) {
          const v = SPEEDS_KMH[pRes.mode] || 0;
          if (v > bestSpeed) {
            bestSpeed = v;
            fastestMode = pRes.mode;
          }
        }

        const reqDest = {
          origin: meetingDestination,
          destination: finalDest,
          travelMode: google.maps.TravelMode[fastestMode],
        };
        const resDest = await routePromise(reqDest);
        rendererDest.setDirections(resDest);

        const legDest = resDest.routes[0]?.legs?.[0];
        let tDest = null;
        if (legDest && legDest.duration) {
          tDest = legDest.duration.value;
          text += `\nMeeting ‚Üí Destination (${fastestMode.toLowerCase()}): ${legDest.distance.text}, ${legDest.duration.text}\n`;

          if (legDest.start_location) bounds.extend(legDest.start_location);
          if (legDest.end_location) bounds.extend(legDest.end_location);
        }

        // Totals to meeting
        let totalMeeting = 0;
        let minT = Infinity;
        let maxT = 0;
        for (const pRes of personResults) {
          totalMeeting += pRes.tMeeting;
          if (pRes.tMeeting < minT) minT = pRes.tMeeting;
          if (pRes.tMeeting > maxT) maxT = pRes.tMeeting;
        }
        const diffMeeting = maxT - minT;
        text += `\nTotal time to meeting (all): ~${Math.round(
          totalMeeting / 60
        )} min\n`;
        text += `Spread at meeting: ~${Math.round(diffMeeting / 60)} min\n`;

        // Totals via meeting + comparison vs direct
        if (tDest != null) {
          text += `\nTotal time to destination via meeting:\n`;

          let sumVia = 0;
          let sumDirect = 0;

          for (const pRes of personResults) {
            const origin = pRes.person.location || pRes.person.address || pRes.person.defaultAddress;
            if (!origin) continue;

            const totalVia = pRes.tMeeting + tDest;
            sumVia += totalVia;

            const directRes = await routePromise({
              origin,
              destination: finalDest,
              travelMode: google.maps.TravelMode[pRes.mode],
            });
            const dLeg = directRes.routes[0]?.legs?.[0];
            const tDirect = dLeg?.duration?.value ?? null;
            if (tDirect != null) {
              sumDirect += tDirect;
            }

            const viaMin = Math.round(totalVia / 60);
            const directMin = tDirect != null ? Math.round(tDirect / 60) : null;

            if (directMin != null) {
              const delta = viaMin - directMin;
              const sign = delta > 0 ? "+" : "";
              text += `- ${pRes.displayName}: direct ~${directMin} min, via meeting ~${viaMin} min (${sign}${delta} min)\n`;
            } else {
              text += `- ${pRes.displayName}: via meeting ~${viaMin} min (direct route unavailable)\n`;
            }
          }

          if (sumVia > 0 && sumDirect > 0) {
            const sumViaMin = Math.round(sumVia / 60);
            const sumDirectMin = Math.round(sumDirect / 60);
            const deltaGroup = sumViaMin - sumDirectMin;
            const signG = deltaGroup > 0 ? "+" : "";
            text += `\nGroup total direct: ~${sumDirectMin} min\n`;
            text += `Group total via meeting: ~${sumViaMin} min\n`;
            text += `Group difference: ${signG}${deltaGroup} min\n`;
          }
        }

        setDetailsText(text);

        if (!bounds.isEmpty()) {
          map.fitBounds(bounds, { padding: 80 });
        }
      } catch (err) {
        console.error("Error in calcRoutes:", err);
        errorSpan.textContent = "Error while computing routes. See console.";
      }
    }

    async function optimizeMeetingPoint() {
      const errorSpan = document.getElementById("error");
      const infoDiv = document.getElementById("info");
      errorSpan.textContent = "";
      infoDiv.textContent = "";

      if (people.length === 0) {
        errorSpan.textContent = "Add at least one person.";
        return;
      }

      const destText = destinationAddress || INITIAL_DEST;
      if (!destText && !destinationLocation) {
        errorSpan.textContent = "Please choose a destination.";
        return;
      }

      const finalDest = destinationLocation || destText;

      showLoading("Checking alternative routes‚Ä¶");

      try {
        let destLatLng = destinationLocation;
        if (!destLatLng) {
          try {
            destLatLng = await new Promise((resolve, reject) => {
              const geocoder = new google.maps.Geocoder();
              geocoder.geocode({ address: destText }, (results, status) => {
                if (status === google.maps.GeocoderStatus.OK && results[0]) {
                  resolve(results[0].geometry.location);
                } else {
                  reject(status);
                }
              });
            });
          } catch (e) {
            console.error("Geocoding destination failed:", e);
            hideLoading();
            errorSpan.textContent = "Could not geocode the destination.";
            return;
          }
        }

        // Phase 1: compute route(s) to destination for each person and sample candidates
        let candidates = [];
        const routeStepsTotal = people.length || 1;
        let routeStepsDone = 0;

        for (const person of people) {
          const originAddress =
            person.address || person.defaultAddress || "";
          const origin = person.location || originAddress;
          const mode = person.modeSelect.value;

          if (!origin) {
            routeStepsDone++;
            const frac = (ROUTE_PHASE_WEIGHT * routeStepsDone) / routeStepsTotal;
            updateLoading("Checking alternative routes‚Ä¶", frac);
            continue;
          }

          const res = await routePromise({
            origin,
            destination: destLatLng,
            travelMode: google.maps.TravelMode[mode],
            provideRouteAlternatives: true,
          });

          if (res.routes && res.routes.length > 0) {
            for (const r of res.routes) {
              if (!r.overview_path) continue;
              const samples = findIntermediatePoints(r.overview_path, 10);
              candidates.push(...samples);
            }
          }

          routeStepsDone++;
          const frac = (ROUTE_PHASE_WEIGHT * routeStepsDone) / routeStepsTotal;
          updateLoading("Checking alternative routes‚Ä¶", frac);
        }

        candidates.push(destLatLng);

        if (candidates.length === 0) {
          hideLoading();
          errorSpan.textContent =
            "Could not generate candidate meeting points along routes.";
          return;
        }

        const seen = new Set();
        candidates = candidates.filter((pt) => {
          const key = pt.lat().toFixed(5) + "," + pt.lng().toFixed(5);
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });

        const evalStepsTotal = Math.max(1, candidates.length * people.length);
        let evalStepsDone = 0;

        let bestPoint = null;
        let bestTotal = Infinity;

        for (const cand of candidates) {
          let total = 0;
          let valid = true;

          for (const person of people) {
            const originAddress =
              person.address || person.defaultAddress || "";
            const origin = person.location || originAddress;
            const mode = person.modeSelect.value;

            if (!origin) {
              valid = false;
              evalStepsDone += 1;
              continue;
            }

            try {
              const res = await routePromise({
                origin,
                destination: cand,
                travelMode: google.maps.TravelMode[mode],
              });
              const leg = res.routes[0]?.legs?.[0];
              if (!leg || !leg.duration) {
                valid = false;
              } else {
                total += leg.duration.value;
              }
            } catch (e) {
              valid = false;
            }

            evalStepsDone += 1;
            const evalFrac = evalStepsDone / evalStepsTotal;
            const globalFrac =
              ROUTE_PHASE_WEIGHT + (1 - ROUTE_PHASE_WEIGHT) * evalFrac;
            updateLoading("Evaluating meeting points‚Ä¶", globalFrac);
          }

          if (!valid) continue;
          if (total < bestTotal) {
            bestTotal = total;
            bestPoint = cand;
          }
        }

        if (!bestPoint) {
          hideLoading();
          errorSpan.textContent =
            "Could not find a good meeting point among candidates.";
          return;
        }

        const safeLatLng = await getSafeMeetingPoint(bestPoint);
        if (!safeLatLng) {
          hideLoading();
          console.warn("getSafeMeetingPoint returned null for", bestPoint);
          errorSpan.textContent =
            "Could not find a safe meeting point nearby.";
          return;
        }

        clearMeetingPoint();
        setMeetingPoint(safeLatLng);
        map.panTo(safeLatLng);

        try {
          const meetingInput = document.getElementById("meeting-input");
          const addr = await reverseGeocodeLatLng(safeLatLng);
          if (addr) {
            meetingAddress = addr;
            if (meetingInput) {
              meetingInput.value = addr;
              if (typeof setValidationState === "function") {
                setValidationState(meetingInput, true);
              }
            }
          }
        } catch (e) {
          console.error("Failed to reverse geocode optimized meeting point:", e);
        }

        updateLoading("Finalizing routes‚Ä¶", 1);
        hideLoading();
        await calcRoutes();
      } catch (err) {
        console.error("Error during optimizeMeetingPoint:", err);
        errorSpan.textContent =
          "Error while optimizing meeting point. See console.";
        hideLoading();
      }
    }

    function setValidationState(el, isValid) {
      el.classList.remove("validated-input", "pending-input");
      el.classList.add(isValid ? "validated-input" : "pending-input");
    }
  </script>

  <!-- LEGAL FOOTER -->
  <footer style="
    background: var(--bg-elevated);
    border-top: 1px solid var(--border-subtle);
    padding: 14px 18px;
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-top: 10px;
    text-align: center;
  ">
    <div id="footerMain" style="margin-bottom:6px;">
      ¬© 2025 ToGather ‚Äî Open-source tool to compute fair meeting points.
    </div>

    <a href="#" id="openPrivacy" style="margin:0 8px; color: var(--accent); text-decoration:none;">Privacy Notice</a>
    ¬∑
    <a href="#" id="openTerms" style="margin:0 8px; color: var(--accent); text-decoration:none;">Terms of Use</a>
    ¬∑
    <a href="mailto:erb.fel@gmail.com" id="contactLink" style="margin:0 8px; color: var(--accent); text-decoration:none;">
      Contact
    </a>
    ¬∑
    <a href="https://github.com/Zwyk/ToGather" target="_blank" style="margin:0 8px; color: var(--accent); text-decoration:none;">
      GitHub
    </a>

    <div style="margin-top:6px;">
      This project uses Google Maps APIs. By using this site you agree to the 
      <a href="https://policies.google.com/terms" target="_blank" style="color: var(--accent);">Google Terms of Service</a>.
    </div>
  </footer>

  <!-- ===== MODALS (Privacy & Terms) ===== -->
  <style>
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999999;
    }
    .modal-box {
      background: var(--bg-elevated);
      max-width: 600px;
      width: 90%;
      padding: 20px;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-box h2 {
      margin-top:0;
      font-size: 1.2rem;
    }
    .modal-close {
      margin-top: 16px;
      display: inline-block;
      background: var(--chip-bg);
      padding: 6px 14px;
      border-radius: 999px;
      cursor: pointer;
      border: 1px solid var(--border-subtle);
    }
  </style>

  <!-- Privacy Modal -->
  <div id="privacyModal" class="modal-overlay">
    <div class="modal-box">
      <h2 id="privacyTitle">Privacy Notice</h2>
      <div id="privacyBody">
        <p>
          ToGather does not collect or store any personally identifiable data.
          Addresses you enter are processed only locally in your browser and sent
          directly to Google Maps services to compute routes and place
          suggestions. No information is transmitted to any server controlled by
          the creator of this tool.
        </p>
        <p>
          Since everything runs client-side, closing your browser window deletes
          all input data. Your browser may keep cached Google Maps results as part
          of normal web operation.
        </p>
        <p>
          By using this tool, you also accept the Google Maps Platform
          <a href="https://policies.google.com/privacy" target="_blank">Privacy Policy</a>.
        </p>
      </div>
      <button class="modal-close" data-close="privacyModal" id="privacyCloseBtn">Close</button>
    </div>
  </div>

  <!-- Terms Modal -->
  <div id="termsModal" class="modal-overlay">
    <div class="modal-box">
      <h2 id="termsTitle">Terms of Use</h2>
      <div id="termsBody">
        <p>
          This tool is provided ‚Äúas-is‚Äù, without warranty of any kind. Results
          may be inaccurate due to real-world traffic variability, address
          coverage, or API limitations. You remain responsible for verifying all
          suggested routes and meeting locations.
        </p>
        <p>
          This project is non-commercial and open-source. You are free to fork,
          reuse, or modify the code under the MIT license (unless stated
          otherwise in the GitHub repository).
        </p>
        <p>
          The creator cannot be held liable for issues arising from inaccurate
          routing or misuse of the tool.
        </p>
      </div>
      <button class="modal-close" data-close="termsModal" id="termsCloseBtn">Close</button>
    </div>
  </div>

  <script>
    function openModal(id) {
      document.getElementById(id).style.display = "flex";
    }

    function closeModal(id) {
      document.getElementById(id).style.display = "none";
    }

    document.getElementById("openPrivacy").onclick = (e) => {
      e.preventDefault();
      openModal("privacyModal");
    };
    document.getElementById("openTerms").onclick = (e) => {
      e.preventDefault();
      openModal("termsModal");
    };

    document.querySelectorAll(".modal-close").forEach(btn => {
      btn.onclick = () => closeModal(btn.dataset.close);
    });

    document.querySelectorAll(".modal-overlay").forEach(bg => {
      bg.addEventListener("click", (e) => {
        if (e.target.classList.contains("modal-overlay")) {
          bg.style.display = "none";
        }
      });
    });
  </script>

  <script>
    function loadGoogleMaps() {
      const existingScript = document.getElementById("gmaps-script");
      if (existingScript) return;

      const script = document.createElement("script");
      script.id = "gmaps-script";
      script.src =
        "https://maps.googleapis.com/maps/api/js" +
        "?key=" + window.GOOGLE_MAPS_API_KEY +
        "&callback=initMap" +
        "&libraries=places" +
        "&v=weekly" +
        "&loading=async";
      script.async = true;
      script.defer = true;
      document.head.appendChild(script);
    }
    loadGoogleMaps();
  </script>
</body>
</html>
