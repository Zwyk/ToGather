<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Directions demo</title>
  <style>
    /* Basic layout */
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #controls {
      padding: 12px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-start;
      z-index: 2;
      background: #fff;
    }
    #controls .block {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 220px;
    }
    #controls button {
      padding: 6px 12px;
      cursor: pointer;
    }
    #map {
      height: calc(100% - 52px); /* full height minus controls */
    }
    #error {
      color: #b00020;
      margin-left: 8px;
      font-size: 0.9em;
    }
  </style>
</head>

<body>
  <div id="controls">
    <div class="block">
      <label>Person 1 address</label>
      <gmp-place-autocomplete
        id="addr1"
        placeholder="Person 1 address"
        style="width: 280px;"
      ></gmp-place-autocomplete>
      <label>
        Mode:
        <select id="mode1">
          <option value="DRIVING" selected>Driving</option>
          <option value="WALKING">Walking</option>
          <option value="BICYCLING">Cycling</option>
          <option value="TRANSIT">Transit</option>
        </select>
      </label>
    </div>

    <div class="block">
      <label>Person 2 address</label>
      <gmp-place-autocomplete
        id="addr2"
        placeholder="Person 2 address"
        style="width: 280px;"
      ></gmp-place-autocomplete>
      <label>
        Mode:
        <select id="mode2">
          <option value="DRIVING">Driving</option>
          <option value="WALKING" selected>Walking</option>
          <option value="BICYCLING">Cycling</option>
          <option value="TRANSIT">Transit</option>
        </select>
      </label>
    </div>

    <div class="block">
      <label>Meeting point</label>
      <gmp-place-autocomplete
        id="meeting"
        placeholder="Optional: choose a meeting place"
        style="width: 280px;"
      ></gmp-place-autocomplete>
      <small id="meetingHint">
        Click on the map to set the meeting point, or choose an address here.
      </small>
    </div>

    <div class="block">
      <label>Destination</label>
      <gmp-place-autocomplete
        id="destination"
        placeholder="Final destination"
        style="width: 280px;"
      ></gmp-place-autocomplete>
    </div>

    <div class="block">
      <button id="routeBtn">Show routes</button>
      <button id="optBtn">Optimize meeting point</button>
      <button id="snapBtn">Snap meeting to safe place</button>
      <span id="error"></span>
    </div>
  </div>

  <div id="info" style="padding: 8px; font-size: 0.9em;"></div>
  <div id="map"></div>

  <!-- Load Maps JS dynamically with your key & mapId that you already set in a separate file -->
  <script src="config.js"></script>
  <script>
    function loadGoogleMaps() {
      const existingScript = document.getElementById("gmaps-script");
      if (existingScript) return;

      const script = document.createElement("script");
      script.id = "gmaps-script";
      script.src =
        "https://maps.googleapis.com/maps/api/js" +
        "?key=" + window.GOOGLE_MAPS_API_KEY +
        "&callback=initMap" +
        "&libraries=marker,places" +
        "&v=weekly" +
        "&loading=async";
      script.async = true;
      script.defer = true;
      document.head.appendChild(script);
    }
    loadGoogleMaps();
  </script>

  <!-- Main logic -->
  <script>
    let map;
    let directionsService;
    let renderer1;
    let renderer2;
    let rendererDest; // Meeting -> Destination

    // Advanced marker for meeting point
    let meetingLatLng = null;
    let meetingMarker = null;

    // Default test addresses (for quick testing)
    const INITIAL_ADDR1 = "10 Rue Daniel Hirtz, Strasbourg, France";
    const INITIAL_ADDR2 = "3 Place Henri Dunant, Strasbourg, France";
    const INITIAL_DEST = "Instant Grimpe, Route Industrielle de la Hardt, Molsheim, France";

    // Stored addresses & locations from PlaceAutocompleteElement
    let addr1Address = "";
    let addr2Address = "";
    let meetingAddress = "";
    let destinationAddress = "";

    let addr1Location = null;
    let addr2Location = null;
    let destinationLocation = null;

    const SPEEDS_KMH = {
      DRIVING: 50,
      WALKING: 5,
      BICYCLING: 15,
      TRANSIT: 25,
    };

    function routePromise(request) {
      return new Promise((resolve, reject) => {
        directionsService.route(request, (result, status) => {
          if (status === google.maps.DirectionsStatus.OK) {
            resolve(result);
          } else {
            reject(status);
          }
        });
      });
    }

    function findIntermediatePoints(path, num) {
      const candidates = [];
      if (!path || path.length < 2 || num <= 0) return candidates;

      const step = Math.floor(path.length / (num + 1));
      if (step <= 0) return candidates;

      for (let i = 1; i <= num; i++) {
        const idx = i * step;
        if (idx > 0 && idx < path.length - 1) {
          candidates.push(path[idx]);
        }
      }
      return candidates;
    }

    // Use Places API (New) Nearby Search to snap to a safe-ish POI
    async function getSafeMeetingPoint(latLng) {
      if (!latLng) return latLng;

      const apiKey = window.GOOGLE_MAPS_API_KEY;
      if (!apiKey) {
        console.warn("No API key available for Places API (new); using original meeting point.");
        return latLng;
      }

      try {
        const center = {
          latitude: typeof latLng.lat === "function" ? latLng.lat() : latLng.lat,
          longitude: typeof latLng.lng === "function" ? latLng.lng() : latLng.lng,
        };

        const requestBody = {
          includedTypes: [
            "cafe",
            "restaurant",
            "parking",
            "park",
            "shopping_mall",
            "transit_station",
            "train_station",
            "bus_station",
            "subway_station",
          ],
          maxResultCount: 10,
          rankPreference: "DISTANCE",
          locationRestriction: {
            circle: {
              center,
              radius: 500.0,
            },
          },
        };

        const response = await fetch("https://places.googleapis.com/v1/places:searchNearby", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Goog-Api-Key": apiKey,
            "X-Goog-FieldMask": "places.location,places.types",
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          console.warn("Nearby Search (new) failed:", response.status, response.statusText);
          return latLng;
        }

        const data = await response.json();
        if (!data.places || data.places.length === 0) {
          return latLng;
        }

        // Prefer “safe-ish” place types, but fall back to the closest result.
        const preferredTypes = [
          "cafe",
          "restaurant",
          "parking",
          "park",
          "shopping_mall",
          "transit_station",
          "train_station",
          "bus_station",
          "subway_station",
        ];

        let chosen = data.places[0];
        for (const place of data.places) {
          if (place.types && place.types.some((t) => preferredTypes.includes(t))) {
            chosen = place;
            break;
          }
        }

        if (
          chosen.location &&
          typeof chosen.location.latitude === "number" &&
          typeof chosen.location.longitude === "number"
        ) {
          return new google.maps.LatLng(
            chosen.location.latitude,
            chosen.location.longitude
          );
        }

        return latLng;
      } catch (err) {
        console.error("Error when calling Places API (new) nearby search:", err);
        return latLng;
      }
    }

    async function snapCurrentMeetingPoint() {
      const errorSpan = document.getElementById("error");
      errorSpan.textContent = "";

      if (!meetingLatLng) {
        errorSpan.textContent =
          "Please choose a meeting point (optimize, click on map, or select an address) before snapping.";
        return;
      }

      try {
        const safeLatLng = await getSafeMeetingPoint(meetingLatLng);

        if (!safeLatLng) {
          errorSpan.textContent = "Could not find a safer place nearby.";
          return;
        }

        // Move marker to the safe place
        clearMeetingPoint();
        setMeetingPoint(safeLatLng);
        map.panTo(safeLatLng);

        // Recompute all routes based on the new meeting point
        await calcRoutes();
      } catch (e) {
        console.error(e);
        errorSpan.textContent =
          "Error while snapping to a safer place. Please try again.";
      }
    }

    function setupAutocompleteElement(elementId, onPlaceSelected) {
      const pac = document.getElementById(elementId);
      if (!pac) return;

      pac.addEventListener("gmp-select", async (event) => {
        const placePrediction = event.detail.placePrediction;
        if (!placePrediction) return;

        const { Place } = await google.maps.importLibrary("places");
        const place = placePrediction.toPlace();
        await place.fetchFields({
          fields: ["location", "displayName", "formattedAddress"],
        });
        onPlaceSelected(place);
      });
    }

    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 6,
        center: { lat: 46.5, lng: 2.5 },
        mapId: window.GOOGLE_MAP_ID,
      });

      directionsService = new google.maps.DirectionsService();
      // Nearby place lookup now uses Places API (new) via HTTP; no legacy PlacesService needed.

      renderer1 = new google.maps.DirectionsRenderer({
        map: map,
        polylineOptions: { strokeColor: "#1a73e8" }, // Person 1
      });

      renderer2 = new google.maps.DirectionsRenderer({
        map: map,
        polylineOptions: { strokeColor: "#e91e63" }, // Person 2
      });

      rendererDest = new google.maps.DirectionsRenderer({
        map: map,
        polylineOptions: { strokeColor: "#00b894" }, // Meeting -> Destination
      });

      document.getElementById("routeBtn").addEventListener("click", () => {
        calcRoutes();
      });

      document.getElementById("optBtn").addEventListener("click", () => {
        optimizeMeetingPoint();
      });

      document.getElementById("snapBtn").addEventListener("click", () => {
        snapCurrentMeetingPoint();
      });

      // Setup new PlaceAutocompleteElement widgets
      setupAutocompleteElement("addr1", (place) => {
        addr1Address = place.formattedAddress || "";
        addr1Location = place.location || null;
      });

      setupAutocompleteElement("addr2", (place) => {
        addr2Address = place.formattedAddress || "";
        addr2Location = place.location || null;
      });

      setupAutocompleteElement("meeting", (place) => {
        meetingAddress = place.formattedAddress || "";
        if (place.location) {
          setMeetingPoint(place.location);
        }
      });

      setupAutocompleteElement("destination", (place) => {
        destinationAddress = place.formattedAddress || "";
        destinationLocation = place.location || null;
      });

      // Click on the map to choose the meeting point
      map.addListener("click", (e) => {
        setMeetingPoint(e.latLng);
        meetingAddress = ""; // "point on map" overrides any typed address
      });
    }

    // Expose initMap for the callback
    window.initMap = initMap;

    function setMeetingPoint(latLng) {
      meetingLatLng = latLng;

      if (!meetingMarker) {
        meetingMarker = new google.maps.marker.AdvancedMarkerElement({
          map,
          position: latLng,
          title: "Meeting point",
        });
      } else {
        meetingMarker.position = latLng;
      }

      const lat = latLng.lat().toFixed(5);
      const lng = latLng.lng().toFixed(5);
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent = `Meeting point set on map at (${lat}, ${lng}).`;
      }
    }

    function clearMeetingPoint() {
      meetingLatLng = null;
      meetingAddress = "";
      if (meetingMarker) {
        meetingMarker.map = null;
        meetingMarker = null;
      }
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent =
          "Click on the map to set the meeting point, or choose an address here.";
      }
    }

    function travelTimeSeconds(distanceMeters, mode) {
      const km = distanceMeters / 1000;
      const speed = SPEEDS_KMH[mode] || 5;
      return (km / speed) * 3600;
    }

    async function calcRoutes() {
      const addr1 = addr1Address || INITIAL_ADDR1;
      const addr2 = addr2Address || INITIAL_ADDR2;
      const mode1 = document.getElementById("mode1").value;
      const mode2 = document.getElementById("mode2").value;
      const destText = destinationAddress || INITIAL_DEST;

      const errorSpan = document.getElementById("error");
      const infoDiv = document.getElementById("info");

      errorSpan.textContent = "";
      infoDiv.textContent = "";

      if (!addr1 || !addr2) {
        errorSpan.textContent =
          "Please select both person addresses from the suggestions.";
        return;
      }
      if (!destText && !destinationLocation) {
        errorSpan.textContent =
          "Please choose a destination (address or place).";
        return;
      }

      // Meeting point is where they go first
      let meetingDestination;
      if (meetingLatLng) {
        meetingDestination = meetingLatLng;
      } else if (meetingAddress) {
        meetingDestination = meetingAddress;
      } else {
        errorSpan.textContent =
          "Please choose a meeting point (click map or select an address).";
        return;
      }

      try {
        const origin1 = addr1Location || addr1;
        const origin2 = addr2Location || addr2;

        const req1 = {
          origin: origin1,
          destination: meetingDestination,
          travelMode: google.maps.TravelMode[mode1],
        };
        const res1 = await routePromise(req1);
        renderer1.setDirections(res1);

        const leg1 = res1.routes[0]?.legs?.[0];
        let text1 = "";
        let t1 = null;

        if (leg1 && leg1.duration) {
          t1 = leg1.duration.value; // seconds
          text1 =
            "Person 1 → Meeting (" +
            mode1.toLowerCase() +
            "): " +
            leg1.distance.text +
            ", " +
            leg1.duration.text +
            ".";
        }

        const req2 = {
          origin: origin2,
          destination: meetingDestination,
          travelMode: google.maps.TravelMode[mode2],
        };
        const res2 = await routePromise(req2);
        renderer2.setDirections(res2);
        const leg2 = res2.routes[0]?.legs?.[0];
        let text2 = "";
        let t2 = null;

        if (leg2 && leg2.duration) {
          t2 = leg2.duration.value;
          text2 =
            "Person 2 → Meeting (" +
            mode2.toLowerCase() +
            "): " +
            leg2.distance.text +
            ", " +
            leg2.duration.text +
            ".";
        }

        const fasterMode =
          t1 !== null && t2 !== null && t1 < t2 ? mode1 : mode2;
        const fastestTravelMode = fasterMode;

        const finalDest = destinationLocation || destText;

        const reqDest = {
          origin: meetingDestination,
          destination: finalDest,
          travelMode: google.maps.TravelMode[fastestTravelMode],
        };
        const resDest = await routePromise(reqDest);
        rendererDest.setDirections(resDest);

        const legDest = resDest.routes[0]?.legs?.[0];

        let textDest = "";
        let tDest = null;
        if (legDest && legDest.duration) {
          tDest = legDest.duration.value;
          textDest =
            "Meeting → Destination (" +
            fastestTravelMode.toLowerCase() +
            "): " +
            legDest.distance.text +
            ", " +
            legDest.duration.text +
            ".";
        }

        const totalMeetingTime = (t1 || 0) + (t2 || 0);
        const diffMeetingTime = Math.abs((t1 || 0) - (t2 || 0));

        let out = "";
        out += text1 + "\n";
        out += text2 + "\n\n";

        out +=
          "Total time to meeting: ~" +
          Math.round(totalMeetingTime / 60) +
          " min\n";
        out +=
          "Difference in duration: ~" +
          Math.round(diffMeetingTime / 60) +
          " min\n\n";

        if (tDest !== null) {
          out += "Meeting → Destination (" + fastestTravelMode.toLowerCase() + "):\n";
          out += "Distance: " + legDest.distance.text + "\n";
          out += "Duration: " + legDest.duration.text + "\n\n";

          const totalToDestination1 = (t1 || 0) + tDest;
          const totalToDestination2 = (t2 || 0) + tDest;
          const diffAtDestination = Math.abs(
            totalToDestination1 - totalToDestination2
          );

          out += "Total time to destination via meeting:\n";
          out +=
            "Person 1: ~" +
            Math.round(totalToDestination1 / 60) +
            " min\n";
          out +=
            "Person 2: ~" +
            Math.round(totalToDestination2 / 60) +
            " min\n";
          out +=
            "Difference at destination: ~" +
            Math.round(diffAtDestination / 60) +
            " min\n\n";

          const directReq1 = {
            origin: origin1,
            destination: finalDest,
            travelMode: google.maps.TravelMode[mode1],
          };
          const directReq2 = {
            origin: origin2,
            destination: finalDest,
            travelMode: google.maps.TravelMode[mode2],
          };

          const [directRes1, directRes2] = await Promise.all([
            routePromise(directReq1),
            routePromise(directReq2),
          ]);

          const directLeg1 = directRes1.routes[0]?.legs?.[0];
          const directLeg2 = directRes2.routes[0]?.legs?.[0];

          const directT1 = directLeg1?.duration?.value ?? null;
          const directT2 = directLeg2?.duration?.value ?? null;

          out += "Comparison with going directly to destination:\n";

          if (directT1 !== null) {
            out +=
              "Person 1: direct ~" +
              Math.round(directT1 / 60) +
              " min, via meeting ~" +
              Math.round(totalToDestination1 / 60) +
              " min (" +
              (Math.round(totalToDestination1 / 60) -
                Math.round(directT1 / 60)) +
              " min)\n";
          }

          if (directT2 !== null) {
            out +=
              "Person 2: direct ~" +
              Math.round(directT2 / 60) +
              " min, via meeting ~" +
              Math.round(totalToDestination2 / 60) +
              " min (" +
              (Math.round(totalToDestination2 / 60) -
                Math.round(directT2 / 60)) +
              " min)\n";
          }
        }

        infoDiv.textContent = out;
      } catch (e) {
        console.error(e);
        errorSpan.textContent =
          "Error while calculating routes. Please check the console.";
      }
    }

    async function optimizeMeetingPoint() {
      const errorSpan = document.getElementById("error");
      const infoDiv = document.getElementById("info");
      errorSpan.textContent = "";
      infoDiv.textContent = "";

      const addr1 = addr1Address || INITIAL_ADDR1;
      const addr2 = addr2Address || INITIAL_ADDR2;
      const destText = destinationAddress || INITIAL_DEST;

      if (!addr1 || !addr2) {
        errorSpan.textContent =
          "Please select both person addresses from the suggestions.";
        return;
      }
      if (!destText && !destinationLocation) {
        errorSpan.textContent =
          "Please choose a destination (address or place).";
        return;
      }

      const mode1 = document.getElementById("mode1").value;
      const mode2 = document.getElementById("mode2").value;

      const origin1 = addr1Location || addr1;
      const origin2 = addr2Location || addr2;
      const finalDest = destinationLocation || destText;

      try {
        const midLatLngPromise = new Promise((resolve, reject) => {
          const geocoder = new google.maps.Geocoder();
          geocoder.geocode({ address: destText }, (results, status) => {
            if (status === google.maps.GeocoderStatus.OK && results[0]) {
              resolve(results[0].geometry.location);
            } else {
              reject(status);
            }
          });
        });

        const destLatLng = (await midLatLngPromise);

        const req1 = {
          origin: origin1,
          destination: destLatLng,
          travelMode: google.maps.TravelMode[mode1],
        };
        const req2 = {
          origin: origin2,
          destination: destLatLng,
          travelMode: google.maps.TravelMode[mode2],
        };

        const [res1, res2] = await Promise.all([
          routePromise(req1),
          routePromise(req2),
        ]);

        const leg1 = res1.routes[0]?.legs?.[0];
        const leg2 = res2.routes[0]?.legs?.[0];

        if (!leg1 || !leg2) {
          errorSpan.textContent =
            "Could not compute routes to destination for both persons.";
          return;
        }

        const path1 = res1.routes[0].overview_path;
        const path2 = res2.routes[0].overview_path;

        const samples1 = findIntermediatePoints(path1, 8);
        const samples2 = findIntermediatePoints(path2, 8);

        const candidates = [];
        for (const p of samples1) candidates.push(p);
        for (const p of samples2) candidates.push(p);

        candidates.push(destLatLng);

        let bestPoint = null;
        let bestTotal = Infinity;

        const origin1ForDir = origin1;
        const origin2ForDir = origin2;

        for (const cand of candidates) {
          const candidateLatLng = cand;

          const candReq1 = {
            origin: origin1ForDir,
            destination: candidateLatLng,
            travelMode: google.maps.TravelMode[mode1],
          };
          const candReq2 = {
            origin: origin2ForDir,
            destination: candidateLatLng,
            travelMode: google.maps.TravelMode[mode2],
          };

          try {
            const [candRes1, candRes2] = await Promise.all([
              routePromise(candReq1),
              routePromise(candReq2),
            ]);

            const candLeg1 = candRes1.routes[0]?.legs?.[0];
            const candLeg2 = candRes2.routes[0]?.legs?.[0];

            if (!candLeg1 || !candLeg2) continue;

            const t1 = candLeg1.duration.value;
            const t2 = candLeg2.duration.value;
            const total = t1 + t2;

            if (total < bestTotal) {
              bestTotal = total;
              bestPoint = candidateLatLng;
            }
          } catch (e) {
            console.warn("Failed candidate:", e);
          }
        }

        if (!bestPoint) {
          errorSpan.textContent =
            "Could not find a good meeting point along the routes.";
          return;
        }

        const safeLatLng = await getSafeMeetingPoint(bestPoint);
        clearMeetingPoint();
        setMeetingPoint(safeLatLng);
        map.panTo(safeLatLng);

        await calcRoutes();
      } catch (e) {
        console.error(e);
        errorSpan.textContent =
          "Error while optimizing meeting point. Please check the console.";
      }
    }
  </script>
</body>
</html>
