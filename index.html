<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ToGather â€“ Fair Meeting Point</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #controls {
      padding: 12px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-start;
      z-index: 2;
      background: #fff;
    }
    .block {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 240px;
    }
    .person-block {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 6px 8px;
      background: #fafafa;
    }
    .person-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      margin-bottom: 4px;
    }
    .person-header button {
      font-size: 0.8em;
      padding: 2px 6px;
    }
    #controls button {
      padding: 6px 12px;
      cursor: pointer;
    }
    #map {
      height: calc(100% - 64px);
    }
    #error {
      color: #b00020;
      font-size: 0.9em;
    }
    #info {
      padding: 8px;
      font-size: 0.9em;
      white-space: pre-line;
    }
  </style>
</head>

<body>
  <div id="controls">
    <div class="block" style="min-width: 320px;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <strong>People</strong>
        <button id="addPersonBtn" type="button">Add person</button>
      </div>
      <small>Each person has an address and a travel mode.</small>
      <div id="people-container" style="display:flex; flex-direction:column; gap:6px; margin-top:4px;"></div>
    </div>

    <div class="block">
      <label>Meeting point</label>
      <gmp-place-autocomplete
        id="meeting"
        placeholder="Choose a meeting place or click on the map"
        style="width: 280px;"
      ></gmp-place-autocomplete>
      <small id="meetingHint">
        Click on the map to set the meeting point, or choose an address here.
      </small>
    </div>

    <div class="block">
      <label>Destination</label>
      <gmp-place-autocomplete
        id="destination"
        placeholder="Final destination"
        style="width: 280px;"
      ></gmp-place-autocomplete>
      <small>Everyone goes here after meeting.</small>
    </div>

    <div class="block">
      <button id="routeBtn" type="button">Show routes</button>
      <button id="optBtn" type="button">Optimize meeting point</button>
      <button id="snapBtn" type="button">Snap meeting to safe place</button>
      <span id="error"></span>
      <small style="margin-top:4px; color:#555;">
        Tip: after typing an address, click a suggestion so the app can use it.
      </small>
    </div>
  </div>

  <div id="info"></div>
  <div id="map"></div>

  <!-- API key + mapId in config.js -->
  <script src="config.js"></script>
  <script>
    function loadGoogleMaps() {
      const existingScript = document.getElementById("gmaps-script");
      if (existingScript) return;

      const script = document.createElement("script");
      script.id = "gmaps-script";
      script.src =
        "https://maps.googleapis.com/maps/api/js" +
        "?key=" + window.GOOGLE_MAPS_API_KEY +
        "&callback=initMap" +
        "&libraries=marker,places" +
        "&v=weekly" +
        "&loading=async";
      script.async = true;
      script.defer = true;
      document.head.appendChild(script);
    }
    loadGoogleMaps();
  </script>

  <script>
    // ---- Global state ----
    let map;
    let directionsService;
    let rendererDest; // Meeting -> Destination
    let personRenderers = [];

    let meetingLatLng = null;
    let meetingMarker = null;

    let meetingAddress = "";
    let destinationAddress = "";
    let destinationLocation = null;

    const SPEEDS_KMH = {
      DRIVING: 50,
      WALKING: 5,
      BICYCLING: 15,
      TRANSIT: 25,
    };

    const COLORS = ["#1a73e8", "#e91e63", "#f57c00", "#6a1b9a", "#388e3c", "#00897b"];

    // Initial test scenario
    const INITIAL_PERSONS = [
      {
        label: "Person 1",
        address: "10 Rue Daniel Hirtz, Strasbourg, France",
        mode: "DRIVING",
      },
      {
        label: "Person 2",
        address: "3 Place Henri Dunant, Strasbourg, France",
        mode: "WALKING",
      },
    ];
    const INITIAL_DEST = "Instant Grimpe, Route Industrielle de la Hardt, Molsheim, France";

    // Dynamic people list
    let people = [];
    let nextPersonId = 1;

    // ---- Helpers ----

    function routePromise(request) {
      return new Promise((resolve, reject) => {
        directionsService.route(request, (result, status) => {
          if (status === google.maps.DirectionsStatus.OK) {
            resolve(result);
          } else {
            reject(status);
          }
        });
      });
    }

    function findIntermediatePoints(path, num) {
      const candidates = [];
      if (!path || path.length < 2 || num <= 0) return candidates;
      const step = Math.floor(path.length / (num + 1));
      if (step <= 0) return candidates;
      for (let i = 1; i <= num; i++) {
        const idx = i * step;
        if (idx > 0 && idx < path.length - 1) {
          candidates.push(path[idx]);
        }
      }
      return candidates;
    }

    // Normalize Place.location to google.maps.LatLng and call callback
    function setupAutocompleteElement(el, onPlaceSelected) {
      if (!el) return;
      el.addEventListener("gmp-select", async (event) => {
        const placePrediction = event.placePrediction;
        if (!placePrediction) {
          console.warn("gmp-select without placePrediction", event);
          return;
        }

        const place = placePrediction.toPlace();
        await place.fetchFields({
          fields: ["location", "displayName", "formattedAddress"],
        });

        if (place.location) {
          const loc = place.location;
          let lat, lng;
          if (loc instanceof google.maps.LatLng) {
            // already fine
          } else if (typeof loc.lat === "function" && typeof loc.lng === "function") {
            // also fine
          } else {
            lat = loc.lat ?? loc.latitude;
            lng = loc.lng ?? loc.longitude;
            place.location = new google.maps.LatLng(lat, lng);
          }
        }

        onPlaceSelected(place);
      });
    }

    // Places API (new) nearby search to find a "safe" meeting place
    async function getSafeMeetingPoint(latLng) {
      if (!latLng) return latLng;

      const apiKey = window.GOOGLE_MAPS_API_KEY;
      if (!apiKey) return latLng;

      const center = {
        latitude: typeof latLng.lat === "function" ? latLng.lat() : latLng.lat,
        longitude: typeof latLng.lng === "function" ? latLng.lng() : latLng.lng,
      };

      const requestBody = {
        includedTypes: [
          "cafe",
          "restaurant",
          "parking",
          "park",
          "shopping_mall",
          "transit_station",
          "train_station",
          "bus_station",
          "subway_station",
        ],
        maxResultCount: 10,
        rankPreference: "DISTANCE",
        locationRestriction: {
          circle: {
            center,
            radius: 500.0,
          },
        },
      };

      try {
        const response = await fetch("https://places.googleapis.com/v1/places:searchNearby", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Goog-Api-Key": apiKey,
            "X-Goog-FieldMask": "places.location,places.types",
          },
          body: JSON.stringify(requestBody),
        });

        if (!response.ok) {
          console.warn("Nearby search failed:", response.status, response.statusText);
          return latLng;
        }

        const data = await response.json();
        if (!data.places || data.places.length === 0) return latLng;

        const preferredTypes = [
          "cafe",
          "restaurant",
          "parking",
          "park",
          "shopping_mall",
          "transit_station",
          "train_station",
          "bus_station",
          "subway_station",
        ];

        let chosen = data.places[0];
        for (const place of data.places) {
          if (place.types && place.types.some((t) => preferredTypes.includes(t))) {
            chosen = place;
            break;
          }
        }

        if (
          chosen.location &&
          typeof chosen.location.latitude === "number" &&
          typeof chosen.location.longitude === "number"
        ) {
          return new google.maps.LatLng(
            chosen.location.latitude,
            chosen.location.longitude
          );
        }

        return latLng;
      } catch (err) {
        console.error("Places Nearby (new) error:", err);
        return latLng;
      }
    }

    async function snapCurrentMeetingPoint() {
      const errorSpan = document.getElementById("error");
      errorSpan.textContent = "";

      if (!meetingLatLng) {
        errorSpan.textContent =
          "Please choose a meeting point (optimize, click on map, or select an address) before snapping.";
        return;
      }

      const safeLatLng = await getSafeMeetingPoint(meetingLatLng);
      if (!safeLatLng) {
        errorSpan.textContent = "Could not find a safer place nearby.";
        return;
      }

      clearMeetingPoint();
      setMeetingPoint(safeLatLng);
      map.panTo(safeLatLng);

      await calcRoutes();
    }

    function setMeetingPoint(latLng) {
      meetingLatLng = latLng;

      if (!meetingMarker) {
        meetingMarker = new google.maps.marker.AdvancedMarkerElement({
          map,
          position: latLng,
          title: "Meeting point",
        });
      } else {
        meetingMarker.position = latLng;
      }

      const lat = latLng.lat().toFixed(5);
      const lng = latLng.lng().toFixed(5);
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent = `Meeting point: (${lat}, ${lng}).`;
      }
    }

    function clearMeetingPoint() {
      meetingLatLng = null;
      if (meetingMarker) {
        meetingMarker.map = null;
        meetingMarker = null;
      }
      const hint = document.getElementById("meetingHint");
      if (hint) {
        hint.textContent =
          "Click on the map to set the meeting point, or choose an address here.";
      }
    }

    function addPerson(initial) {
      const id = nextPersonId++;
      const labelText = initial?.label || `Person ${id}`;

      const container = document.getElementById("people-container");
      const wrapper = document.createElement("div");
      wrapper.className = "person-block";
      wrapper.dataset.personId = String(id);

      wrapper.innerHTML = `
        <div class="person-header">
          <span>${labelText}</span>
          <button type="button" class="delete-person">Delete</button>
        </div>
        <label>Address</label>
        <gmp-place-autocomplete
          placeholder="${labelText} address"
          style="width: 260px;"
        ></gmp-place-autocomplete>
        <label style="margin-top:4px;">
          Mode:
          <select>
            <option value="DRIVING">Driving</option>
            <option value="WALKING">Walking</option>
            <option value="BICYCLING">Cycling</option>
            <option value="TRANSIT">Transit</option>
          </select>
        </label>
      `;

      container.appendChild(wrapper);

      const autocompleteEl = wrapper.querySelector("gmp-place-autocomplete");
      const modeSelect = wrapper.querySelector("select");
      const deleteBtn = wrapper.querySelector(".delete-person");

      const person = {
        id,
        label: labelText,
        element: wrapper,
        autocompleteEl,
        modeSelect,
        address: initial?.address || "",
        location: null,
        defaultAddress: initial?.address || "",
      };

      if (initial?.mode) {
        modeSelect.value = initial.mode;
      }

      setupAutocompleteElement(autocompleteEl, (place) => {
        person.address = place.formattedAddress || "";
        person.location = place.location || null;
      });

      deleteBtn.addEventListener("click", () => {
        people = people.filter((p) => p !== person);
        wrapper.remove();
      });

      people.push(person);
    }

    // ---- Map init ----
    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 11,
        center: { lat: 48.5734, lng: 7.7521 }, // Strasbourg-ish
        mapId: window.GOOGLE_MAP_ID,
      });

      directionsService = new google.maps.DirectionsService();
      rendererDest = new google.maps.DirectionsRenderer({
        map,
        polylineOptions: { strokeColor: "#00b894" },
      });

      document.getElementById("routeBtn").addEventListener("click", () => {
        calcRoutes();
      });

      document.getElementById("optBtn").addEventListener("click", () => {
        optimizeMeetingPoint();
      });

      document.getElementById("snapBtn").addEventListener("click", () => {
        snapCurrentMeetingPoint();
      });

      document.getElementById("addPersonBtn").addEventListener("click", () => {
        addPerson();
      });

      // Meeting autocomplete
      setupAutocompleteElement(
        document.getElementById("meeting"),
        (place) => {
          meetingAddress = place.formattedAddress || "";
          if (place.location) {
            setMeetingPoint(place.location);
          } else {
            clearMeetingPoint();
          }
        }
      );

      // Destination autocomplete
      setupAutocompleteElement(
        document.getElementById("destination"),
        (place) => {
          destinationAddress = place.formattedAddress || "";
          destinationLocation = place.location || null;
        }
      );

      // Initial scenario: 2 people
      INITIAL_PERSONS.forEach((p) => addPerson(p));

      // Meeting from map click
      map.addListener("click", (e) => {
        setMeetingPoint(e.latLng);
        meetingAddress = "";
      });
    }
    window.initMap = initMap;

    // ---- Core logic: routes & optimization ----

    async function calcRoutes() {
      const errorSpan = document.getElementById("error");
      const infoDiv = document.getElementById("info");
      errorSpan.textContent = "";
      infoDiv.textContent = "";

      if (people.length === 0) {
        errorSpan.textContent = "Add at least one person.";
        return;
      }

      const destText = destinationAddress || INITIAL_DEST;
      if (!destText && !destinationLocation) {
        errorSpan.textContent = "Please choose a destination.";
        return;
      }
      const finalDest = destinationLocation || destText;

      let meetingDestination;
      if (meetingLatLng) {
        meetingDestination = meetingLatLng;
      } else if (meetingAddress) {
        meetingDestination = meetingAddress;
      } else {
        errorSpan.textContent =
          "Please choose a meeting point (click map or select an address).";
        return;
      }

      // Clear old person polylines
      personRenderers.forEach((r) => r.setMap(null));
      personRenderers = [];

      let text = "";
      const personResults = [];

      try {
        // For each person: origin -> meeting
        let idx = 0;
        for (const person of people) {
          const displayName = person.label || `Person ${idx + 1}`;
          const originAddress =
            person.address || person.defaultAddress || "";
          const mode = person.modeSelect.value;

          if (!originAddress && !person.location) {
            errorSpan.textContent =
              `Please select an address for ${displayName}.`;
            return;
          }

          const origin = person.location || originAddress;
          const req = {
            origin,
            destination: meetingDestination,
            travelMode: google.maps.TravelMode[mode],
          };
          const res = await routePromise(req);

          const renderer = new google.maps.DirectionsRenderer({
            map,
            polylineOptions: { strokeColor: COLORS[idx % COLORS.length] },
          });
          renderer.setDirections(res);
          personRenderers.push(renderer);

          const leg = res.routes[0]?.legs?.[0];
          if (!leg || !leg.duration) continue;

          const t = leg.duration.value;
          const dText = leg.distance?.text || "?";
          const tText = leg.duration?.text || "?";

          personResults.push({
            person,
            displayName,
            mode,
            tMeeting: t,
          });

          text += `${displayName} â†’ Meeting (${mode.toLowerCase()}): ${dText}, ${tText}\n`;
          idx++;
        }

        if (personResults.length === 0) {
          errorSpan.textContent = "Could not compute routes to meeting.";
          return;
        }

        // Meeting â†’ Destination : choose intrinsically fastest mode
        let fastestMode = "WALKING";
        let bestSpeed = 0;
        for (const pRes of personResults) {
          const v = SPEEDS_KMH[pRes.mode] || 0;
          if (v > bestSpeed) {
            bestSpeed = v;
            fastestMode = pRes.mode;
          }
        }

        const reqDest = {
          origin: meetingDestination,
          destination: finalDest,
          travelMode: google.maps.TravelMode[fastestMode],
        };
        const resDest = await routePromise(reqDest);
        rendererDest.setDirections(resDest);

        const legDest = resDest.routes[0]?.legs?.[0];
        let tDest = null;
        if (legDest && legDest.duration) {
          tDest = legDest.duration.value;
          text += `\nMeeting â†’ Destination (${fastestMode.toLowerCase()}): ${legDest.distance.text}, ${legDest.duration.text}\n`;
        }

        // Totals to meeting
        let totalMeeting = 0;
        let minT = Infinity;
        let maxT = 0;
        for (const pRes of personResults) {
          totalMeeting += pRes.tMeeting;
          if (pRes.tMeeting < minT) minT = pRes.tMeeting;
          if (pRes.tMeeting > maxT) maxT = pRes.tMeeting;
        }
        const diffMeeting = maxT - minT;
        text += `\nTotal time to meeting (all): ~${Math.round(
          totalMeeting / 60
        )} min\n`;
        text += `Spread at meeting: ~${Math.round(diffMeeting / 60)} min\n`;

        // Totals via meeting + comparison vs direct
        if (tDest != null) {
          text += `\nTotal time to destination via meeting:\n`;

          let sumVia = 0;
          let sumDirect = 0;

          for (const pRes of personResults) {
            const origin = pRes.person.location || pRes.person.address || pRes.person.defaultAddress;
            if (!origin) continue;

            const totalVia = pRes.tMeeting + tDest;
            sumVia += totalVia;

            const directRes = await routePromise({
              origin,
              destination: finalDest,
              travelMode: google.maps.TravelMode[pRes.mode],
            });
            const dLeg = directRes.routes[0]?.legs?.[0];
            const tDirect = dLeg?.duration?.value ?? null;
            if (tDirect != null) {
              sumDirect += tDirect;
            }

            const viaMin = Math.round(totalVia / 60);
            const directMin = tDirect != null ? Math.round(tDirect / 60) : null;

            if (directMin != null) {
              const delta = viaMin - directMin;
              const sign = delta > 0 ? "+" : "";
              text += `- ${pRes.displayName}: direct ~${directMin} min, via meeting ~${viaMin} min (${sign}${delta} min)\n`;
            } else {
              text += `- ${pRes.displayName}: via meeting ~${viaMin} min (direct route unavailable)\n`;
            }
          }

          if (sumVia > 0 && sumDirect > 0) {
            const sumViaMin = Math.round(sumVia / 60);
            const sumDirectMin = Math.round(sumDirect / 60);
            const deltaGroup = sumViaMin - sumDirectMin;
            const signG = deltaGroup > 0 ? "+" : "";
            text += `\nGroup total direct: ~${sumDirectMin} min\n`;
            text += `Group total via meeting: ~${sumViaMin} min\n`;
            text += `Group difference: ${signG}${deltaGroup} min\n`;
          }
        }

        document.getElementById("info").textContent = text;
      } catch (err) {
        console.error("Error in calcRoutes:", err);
        errorSpan.textContent = "Error while computing routes. See console.";
      }
    }

    async function optimizeMeetingPoint() {
      const errorSpan = document.getElementById("error");
      const infoDiv = document.getElementById("info");
      errorSpan.textContent = "";
      infoDiv.textContent = "";

      if (people.length === 0) {
        errorSpan.textContent = "Add at least one person.";
        return;
      }

      const destText = destinationAddress || INITIAL_DEST;
      if (!destText && !destinationLocation) {
        errorSpan.textContent = "Please choose a destination.";
        return;
      }

      const finalDest = destinationLocation || destText;

      // Get destination LatLng (if we only have a string)
      let destLatLng = destinationLocation;
      if (!destLatLng) {
        try {
          destLatLng = await new Promise((resolve, reject) => {
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ address: destText }, (results, status) => {
              if (status === google.maps.GeocoderStatus.OK && results[0]) {
                resolve(results[0].geometry.location);
              } else {
                reject(status);
              }
            });
          });
        } catch (e) {
          console.error("Geocoding destination failed:", e);
          errorSpan.textContent = "Could not geocode the destination.";
          return;
        }
      }

      // For each person, compute route(s) to destination and sample points
      let candidates = [];
      try {
        for (const person of people) {
          const originAddress =
            person.address || person.defaultAddress || "";
          const origin = person.location || originAddress;
          const mode = person.modeSelect.value;

          if (!origin) continue;

          const res = await routePromise({
            origin,
            destination: destLatLng,
            travelMode: google.maps.TravelMode[mode],
            provideRouteAlternatives: true, // âœ… explore alt routes
          });

          if (!res.routes || res.routes.length === 0) continue;

          for (const r of res.routes) {
            if (!r.overview_path) continue;
            const samples = findIntermediatePoints(r.overview_path, 10); // âœ… more samples
            candidates.push(...samples);
          }
        }

        // Also consider the destination itself as candidate
        candidates.push(destLatLng);

        if (candidates.length === 0) {
          errorSpan.textContent =
            "Could not generate candidate meeting points along routes.";
          return;
        }

        // ðŸ§¹ Deduplicate candidates by rounding
        const seen = new Set();
        candidates = candidates.filter((pt) => {
          const key = pt.lat().toFixed(5) + "," + pt.lng().toFixed(5);
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });

        let bestPoint = null;
        let bestTotal = Infinity;

        // Evaluate each candidate: sum of travel times for all persons to candidate
        for (const cand of candidates) {
          let total = 0;
          let valid = true;

          for (const person of people) {
            const originAddress =
              person.address || person.defaultAddress || "";
            const origin = person.location || originAddress;
            const mode = person.modeSelect.value;

            if (!origin) {
              valid = false;
              break;
            }

            try {
              const res = await routePromise({
                origin,
                destination: cand,
                travelMode: google.maps.TravelMode[mode],
              });
              const leg = res.routes[0]?.legs?.[0];
              if (!leg || !leg.duration) {
                valid = false;
                break;
              }
              total += leg.duration.value;
            } catch (e) {
              valid = false;
              break;
            }
          }

          if (!valid) continue;
          if (total < bestTotal) {
            bestTotal = total;
            bestPoint = cand;
          }
        }

        if (!bestPoint) {
          errorSpan.textContent =
            "Could not find a good meeting point among candidates.";
          return;
        }

        const safeLatLng = await getSafeMeetingPoint(bestPoint);
        clearMeetingPoint();
        setMeetingPoint(safeLatLng);
        map.panTo(safeLatLng);

        await calcRoutes();
      } catch (err) {
        console.error("Error during optimizeMeetingPoint:", err);
        errorSpan.textContent =
          "Error while optimizing meeting point. See console.";
      }
    }
  </script>
</body>
</html>
